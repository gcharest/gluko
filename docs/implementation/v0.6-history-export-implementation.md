# v0.6 History Export & Import - Implementation Guide

## Overview

This document provides detailed technical specifications for implementing v0.6 features:

1. **Export/Import**: JSON-based history backup and restore
2. **History Detail View**: Expandable cards showing full nutrient lists
3. **History Editing**: Load history entries into calculator with safeguards

### Design Principles

- **View Isolation**: Each view (History, Calculator) manages its own state independently
- **Shared State via Stores**: Communication between views only through Pinia stores
- **No Direct Dependencies**: Views don't import or reference each other
- **Router-mediated Navigation**: Navigation handled by Vue Router with route guards
- **Reusable Components**: Shared UI components (dialogs, confirmations) live in `src/components/base/`

### Architecture Goals

- History view can be refactored without touching calculator
- Calculator can be modified without breaking history
- Clear contracts between views via store actions/getters
- Testable in isolation (unit tests don't require cross-view setup)

---

## Implementation Phases

### Phase 0: Export/Import Infrastructure

**Goal**: Enable users to export and import meal history as JSON files

**Estimated Complexity**: Medium

**Dependencies**: None

**Components**:
- Export functionality in `useMealHistoryStore`
- Import functionality with validation
- UI buttons in `MealHistoryView.vue`
- File download/upload utilities

### Phase 1: Expandable History Cards

**Goal**: Users can expand a history card to view full nutrient details (read-only)

**Estimated Complexity**: Low

**Dependencies**: Phase 0 (optional, can be parallel)

**Components**:
- Enhanced `MealHistoryCard.vue` with expand/collapse
- Nutrient list display component
- Accessibility (ARIA, keyboard nav)

### Phase 2: Edit via Calculator with Safeguards

**Goal**: Users can load history entries into calculator for editing, with protection against data loss

**Estimated Complexity**: High

**Dependencies**: Phase 1 (expandable cards should work first)

**Components**:
- Dirty state tracking in `useMealStore`
- `loadFromHistory` action in `useMealStore`
- Confirmation dialog component
- Route guards for unsaved changes
- Edit mode indicator in calculator

### Phase 3: UX Polish

**Goal**: Smooth workflows for editing and duplicating history entries

**Estimated Complexity**: Medium

**Dependencies**: Phase 2 (edit flow must work)

**Components**:
- Edit/duplicate navigation flow
- Toast notifications
- Breadcrumb navigation
- Loading states

---

## Phase 0: Export/Import Infrastructure

### 0.1 Data Format Specification

**Export JSON Structure**:

```typescript
interface HistoryExport {
  version: string // Schema version, e.g., "1.0"
  exportedAt: string // ISO 8601 timestamp
  metadata: {
    appVersion: string // gluko app version
    entryCount: number
    subjects: Array<{ id: string; name: string }>
  }
  entries: MealHistoryEntry[]
}
```

**Schema Versioning**:
- Current version: `"1.0"`
- Future versions: `"1.1"`, `"2.0"`, etc.
- Import must handle version mismatches gracefully

### 0.2 Store Actions (useMealHistoryStore)

**New Actions**:

```typescript
// Export all history entries for current subject or all subjects
exportHistory(options?: { subjectId?: string }): HistoryExport

// Import history from JSON, with merge strategy
importHistory(
  data: HistoryExport,
  strategy: 'merge' | 'replace'
): Promise<{ imported: number; skipped: number; errors: string[] }>

// Validate import file structure and version
validateImport(data: unknown): { valid: boolean; errors: string[]; version?: string }
```

**Implementation Details**:

```typescript
// src/stores/mealHistory.ts

const exportHistory = (options?: { subjectId?: string }): HistoryExport => {
  const entriesToExport = options?.subjectId
    ? entries.value.filter(e => e.subjectId === options.subjectId)
    : entries.value

  // Get unique subjects
  const subjectIds = new Set(entriesToExport.map(e => e.subjectId))
  const subjects = Array.from(subjectIds)
    .map(id => subjectStore.subjectById(id))
    .filter(s => s !== undefined)
    .map(s => ({ id: s.id, name: s.name }))

  return {
    version: '1.0',
    exportedAt: new Date().toISOString(),
    metadata: {
      appVersion: import.meta.env.VITE_APP_VERSION || '0.6.0',
      entryCount: entriesToExport.length,
      subjects
    },
    entries: entriesToExport
  }
}

const validateImport = (data: unknown): { valid: boolean; errors: string[]; version?: string } => {
  const errors: string[] = []

  // Check basic structure
  if (!data || typeof data !== 'object') {
    errors.push('Invalid file format: not a JSON object')
    return { valid: false, errors }
  }

  const importData = data as Partial<HistoryExport>

  // Check version
  if (!importData.version || typeof importData.version !== 'string') {
    errors.push('Missing or invalid version field')
  } else if (!importData.version.match(/^\d+\.\d+$/)) {
    errors.push(`Invalid version format: ${importData.version}`)
  }

  // Check required fields
  if (!importData.exportedAt) errors.push('Missing exportedAt timestamp')
  if (!importData.metadata) errors.push('Missing metadata')
  if (!Array.isArray(importData.entries)) errors.push('Missing or invalid entries array')

  // Validate entries structure
  if (Array.isArray(importData.entries)) {
    importData.entries.forEach((entry, index) => {
      if (!entry.id) errors.push(`Entry ${index}: missing id`)
      if (!entry.subjectId) errors.push(`Entry ${index}: missing subjectId`)
      if (!entry.date) errors.push(`Entry ${index}: missing date`)
      if (!Array.isArray(entry.nutrients)) errors.push(`Entry ${index}: invalid nutrients array`)
    })
  }

  return {
    valid: errors.length === 0,
    errors,
    version: importData.version
  }
}

const importHistory = async (
  data: HistoryExport,
  strategy: 'merge' | 'replace'
): Promise<{ imported: number; skipped: number; errors: string[] }> => {
  const result = { imported: 0, skipped: 0, errors: [] as string[] }

  try {
    // Validate first
    const validation = validateImport(data)
    if (!validation.valid) {
      result.errors.push(...validation.errors)
      return result
    }

    // Handle version compatibility
    if (data.version !== '1.0') {
      result.errors.push(`Unsupported version: ${data.version}. Current version: 1.0`)
      return result
    }

    // Replace strategy: clear existing entries first
    if (strategy === 'replace') {
      const currentEntries = [...entries.value]
      for (const entry of currentEntries) {
        await db.removeMealHistory(entry.id)
      }
      entries.value = []
    }

    // Import entries
    const existingIds = new Set(entries.value.map(e => e.id))

    for (const entry of data.entries) {
      try {
        // Skip duplicates in merge mode
        if (strategy === 'merge' && existingIds.has(entry.id)) {
          result.skipped++
          continue
        }

        // Convert date strings to Date objects
        const importedEntry: MealHistoryEntry = {
          ...entry,
          date: new Date(entry.date),
          metadata: {
            ...entry.metadata,
            created: new Date(entry.metadata.created),
            lastModified: new Date(entry.metadata.lastModified)
          }
        }

        // Save to IndexedDB
        await db.saveMealHistory(importedEntry)
        entries.value.push(importedEntry)
        result.imported++
      } catch (err) {
        result.errors.push(`Failed to import entry ${entry.id}: ${err}`)
      }
    }

    // Re-sort entries
    entries.value.sort((a, b) => b.date.getTime() - a.date.getTime())

  } catch (err) {
    result.errors.push(`Import failed: ${err}`)
  }

  return result
}
```

### 0.3 File Handling Utilities

**New Utility File**: `src/utils/fileHandling.ts`

```typescript
/**
 * Download data as JSON file
 * @param data - Object to serialize as JSON
 * @param filename - Suggested filename (without extension)
 */
export function downloadJSON(data: unknown, filename: string): void {
  const jsonString = JSON.stringify(data, null, 2)
  const blob = new Blob([jsonString], { type: 'application/json' })
  const url = URL.createObjectURL(blob)

  const link = document.createElement('a')
  link.href = url
  link.download = `${filename}.json`
  link.click()

  // Clean up
  URL.revokeObjectURL(url)
}

/**
 * Read JSON file from user file input
 * @param file - File object from input[type=file]
 * @returns Parsed JSON object
 */
export function readJSONFile(file: File): Promise<unknown> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader()

    reader.onload = (event) => {
      try {
        const result = event.target?.result
        if (typeof result !== 'string') {
          throw new Error('File content is not a string')
        }
        const data = JSON.parse(result)
        resolve(data)
      } catch (err) {
        reject(new Error(`Failed to parse JSON: ${err}`))
      }
    }

    reader.onerror = () => {
      reject(new Error('Failed to read file'))
    }

    reader.readAsText(file)
  })
}

/**
 * Generate filename for export
 * @param prefix - Filename prefix (e.g., 'gluko-history')
 * @param subjectName - Optional subject name for single-subject exports
 * @returns Formatted filename with timestamp
 */
export function generateExportFilename(
  prefix: string,
  subjectName?: string
): string {
  const timestamp = new Date().toISOString().split('T')[0] // YYYY-MM-DD
  const subjectPart = subjectName ? `-${subjectName.replace(/\s+/g, '-')}` : ''
  return `${prefix}${subjectPart}-${timestamp}`
}
```

**Usage Example**:

```typescript
// Export
const exportData = mealHistoryStore.exportHistory()
const filename = generateExportFilename('gluko-history', currentSubject?.name)
downloadJSON(exportData, filename)

// Import
const handleFileSelect = async (event: Event) => {
  const input = event.target as HTMLInputElement
  const file = input.files?.[0]
  if (!file) return

  try {
    const data = await readJSONFile(file)
    const result = await mealHistoryStore.importHistory(data as HistoryExport, 'merge')
    // Show success/error messages
  } catch (err) {
    // Handle error
  }
}
```

### 0.4 UI Components

#### 0.4.1 Export/Import Buttons (MealHistoryView.vue)

**Location**: Already exists in template (lines 66-73)

**Implementation**:

```vue
<script setup lang="ts">
import { ref } from 'vue'
import { useMealHistoryStore } from '@/stores/mealHistory'
import { useSubjectStore } from '@/stores/subject'
import { downloadJSON, readJSONFile, generateExportFilename } from '@/utils/fileHandling'
import type { HistoryExport } from '@/types/meal-history'

const mealHistoryStore = useMealHistoryStore()
const subjectStore = useSubjectStore()

const fileInputRef = ref<HTMLInputElement | null>(null)
const importLoading = ref(false)
const importError = ref<string | null>(null)

function handleExport() {
  try {
    const exportData = mealHistoryStore.exportHistory()
    const filename = generateExportFilename(
      'gluko-history',
      subjectStore.currentSubject?.name
    )
    downloadJSON(exportData, filename)

    // Show success toast (Phase 3)
    console.log('Export successful')
  } catch (err) {
    console.error('Export failed:', err)
    importError.value = err instanceof Error ? err.message : 'Export failed'
  }
}

function handleImport() {
  // Trigger file input click
  fileInputRef.value?.click()
}

async function handleFileSelect(event: Event) {
  const input = event.target as HTMLInputElement
  const file = input.files?.[0]
  if (!file) return

  importLoading.value = true
  importError.value = null

  try {
    const data = await readJSONFile(file)

    // Validate
    const validation = mealHistoryStore.validateImport(data)
    if (!validation.valid) {
      throw new Error(validation.errors.join(', '))
    }

    // Show merge strategy dialog (see 0.4.2)
    showMergeStrategyDialog.value = true
    pendingImportData.value = data as HistoryExport
  } catch (err) {
    importError.value = err instanceof Error ? err.message : 'Import failed'
  } finally {
    importLoading.value = false
    // Reset input
    input.value = ''
  }
}

// Hidden file input
<input
  ref="fileInputRef"
  type="file"
  accept=".json,application/json"
  class="hidden"
  @change="handleFileSelect"
/>
</script>
```

#### 0.4.2 Merge Strategy Dialog

**New Component**: `src/components/dialogs/ImportMergeDialog.vue`

```vue
<template>
  <BaseDialog :open="open" @close="$emit('cancel')">
    <template #title>
      {{ $t('dialogs.importMerge.title') }}
    </template>

    <div class="space-y-4">
      <p class="text-gray-600 dark:text-gray-400">
        {{ $t('dialogs.importMerge.message', { count: entryCount }) }}
      </p>

      <div class="space-y-2">
        <label class="flex items-start gap-3 p-3 border rounded-lg cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-800">
          <input
            v-model="selectedStrategy"
            type="radio"
            name="merge-strategy"
            value="merge"
            class="mt-1"
          />
          <div>
            <div class="font-medium">{{ $t('dialogs.importMerge.merge.title') }}</div>
            <div class="text-sm text-gray-600 dark:text-gray-400">
              {{ $t('dialogs.importMerge.merge.description') }}
            </div>
          </div>
        </label>

        <label class="flex items-start gap-3 p-3 border rounded-lg cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-800">
          <input
            v-model="selectedStrategy"
            type="radio"
            name="merge-strategy"
            value="replace"
            class="mt-1"
          />
          <div>
            <div class="font-medium">{{ $t('dialogs.importMerge.replace.title') }}</div>
            <div class="text-sm text-gray-600 dark:text-gray-400">
              {{ $t('dialogs.importMerge.replace.description') }}
            </div>
            <div class="text-sm text-danger-600 dark:text-danger-400 mt-1">
              ⚠️ {{ $t('dialogs.importMerge.replace.warning') }}
            </div>
          </div>
        </label>
      </div>
    </div>

    <template #actions>
      <BaseButton variant="secondary" @click="$emit('cancel')">
        {{ $t('common.cancel') }}
      </BaseButton>
      <BaseButton variant="primary" @click="$emit('confirm', selectedStrategy)">
        {{ $t('common.import') }}
      </BaseButton>
    </template>
  </BaseDialog>
</template>

<script setup lang="ts">
import { ref } from 'vue'
import BaseDialog from '@/components/base/BaseDialog.vue'
import BaseButton from '@/components/base/BaseButton.vue'

interface Props {
  open: boolean
  entryCount: number
}

defineProps<Props>()
defineEmits(['confirm', 'cancel'])

const selectedStrategy = ref<'merge' | 'replace'>('merge')
</script>
```

#### 0.4.3 Progress/Result Toast

**Usage**: Show import results after completion

```typescript
// After import completes
const result = await mealHistoryStore.importHistory(data, strategy)

if (result.errors.length > 0) {
  // Show error toast
  showToast({
    variant: 'danger',
    message: $t('toasts.import.error', { errors: result.errors.join(', ') })
  })
} else {
  // Show success toast
  showToast({
    variant: 'success',
    message: $t('toasts.import.success', {
      imported: result.imported,
      skipped: result.skipped
    })
  })
}
```

### 0.5 Validation & Error Handling

#### Error Scenarios

| Scenario               | Validation                  | User Feedback                                                            |
| ---------------------- | --------------------------- | ------------------------------------------------------------------------ |
| Invalid JSON syntax    | Parse error caught          | "File is not valid JSON"                                                 |
| Missing version field  | `validateImport` check      | "Import file missing version information"                                |
| Unsupported version    | Version comparison          | "This file was created with a newer version (2.0). Current version: 1.0" |
| Malformed entries      | Entry field validation      | "Entry 5 is missing required field: nutrients"                           |
| File too large (>10MB) | File size check before read | "File is too large. Maximum size: 10MB"                                  |
| Network/storage error  | IndexedDB error             | "Failed to save imported data. Check storage quota"                      |
| Duplicate IDs in merge | ID collision detection      | "X entries skipped (already exist)"                                      |

#### Validation Flow

```typescript
// Step 1: File size check (before reading)
if (file.size > 10 * 1024 * 1024) {
  throw new Error('File too large')
}

// Step 2: JSON parse
let data: unknown
try {
  data = await readJSONFile(file)
} catch (err) {
  throw new Error('Invalid JSON file')
}

// Step 3: Structure validation
const validation = mealHistoryStore.validateImport(data)
if (!validation.valid) {
  throw new Error(validation.errors.join('\n'))
}

// Step 4: Version compatibility
if (validation.version !== '1.0') {
  throw new Error(`Unsupported version: ${validation.version}`)
}

// Step 5: Import with error collection
const result = await mealHistoryStore.importHistory(data, strategy)
if (result.errors.length > 0) {
  // Partial success: some imported, some failed
  showPartialSuccessMessage(result)
} else {
  showSuccessMessage(result)
}
```

#### Error Recovery

- **Partial import failure**: Show count of successful imports and list of errors
- **Total failure**: No data written, original state preserved
- **Replace failure**: Attempt to restore from backup (transaction-like behavior)

#### User-Friendly Error Messages

```typescript
const ERROR_MESSAGES: Record<string, string> = {
  'invalid-json': 'The selected file is not a valid JSON file',
  'missing-version': 'This file is missing version information and may be corrupted',
  'unsupported-version': 'This file was created with a different version of the app',
  'malformed-entry': 'Some entries in the file are incomplete or corrupted',
  'storage-quota': 'Not enough storage space to import all entries',
  'file-too-large': 'The file is too large to import (maximum 10MB)'
}
```

### 0.6 Testing Requirements

#### Unit Tests

**File**: `src/stores/__tests__/mealHistory.export.spec.ts`

```typescript
import { describe, it, expect, beforeEach } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'
import { useMealHistoryStore } from '@/stores/mealHistory'
import type { HistoryExport } from '@/types/meal-history'

describe('mealHistory - export/import', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
  })

  describe('exportHistory', () => {
    it('exports all entries with correct structure', () => {
      const store = useMealHistoryStore()
      // Add test entries
      const exported = store.exportHistory()

      expect(exported.version).toBe('1.0')
      expect(exported.exportedAt).toBeDefined()
      expect(exported.metadata.entryCount).toBe(store.entries.length)
      expect(Array.isArray(exported.entries)).toBe(true)
    })

    it('filters by subject when subjectId provided', () => {
      const store = useMealHistoryStore()
      // Add entries for different subjects
      const exported = store.exportHistory({ subjectId: 'subject-1' })

      expect(exported.entries.every(e => e.subjectId === 'subject-1')).toBe(true)
    })

    it('includes subject metadata', () => {
      const store = useMealHistoryStore()
      const exported = store.exportHistory()

      expect(Array.isArray(exported.metadata.subjects)).toBe(true)
      expect(exported.metadata.subjects[0]).toHaveProperty('id')
      expect(exported.metadata.subjects[0]).toHaveProperty('name')
    })
  })

  describe('validateImport', () => {
    it('accepts valid export structure', () => {
      const store = useMealHistoryStore()
      const validData: HistoryExport = {
        version: '1.0',
        exportedAt: new Date().toISOString(),
        metadata: { appVersion: '0.6.0', entryCount: 0, subjects: [] },
        entries: []
      }

      const result = store.validateImport(validData)
      expect(result.valid).toBe(true)
      expect(result.errors).toHaveLength(0)
    })

    it('rejects invalid JSON', () => {
      const store = useMealHistoryStore()
      const result = store.validateImport(null)

      expect(result.valid).toBe(false)
      expect(result.errors.length).toBeGreaterThan(0)
    })

    it('detects missing version', () => {
      const store = useMealHistoryStore()
      const invalidData = { exportedAt: new Date().toISOString(), entries: [] }

      const result = store.validateImport(invalidData)
      expect(result.valid).toBe(false)
      expect(result.errors).toContain(expect.stringContaining('version'))
    })

    it('validates entry structure', () => {
      const store = useMealHistoryStore()
      const invalidData = {
        version: '1.0',
        exportedAt: new Date().toISOString(),
        metadata: { appVersion: '0.6.0', entryCount: 1, subjects: [] },
        entries: [{ id: 'test' }] // Missing required fields
      }

      const result = store.validateImport(invalidData)
      expect(result.valid).toBe(false)
    })
  })

  describe('importHistory', () => {
    it('imports valid data in merge mode', async () => {
      const store = useMealHistoryStore()
      const validData: HistoryExport = {
        version: '1.0',
        exportedAt: new Date().toISOString(),
        metadata: { appVersion: '0.6.0', entryCount: 1, subjects: [] },
        entries: [
          {
            id: 'new-entry',
            subjectId: 'subject-1',
            date: new Date(),
            tags: [],
            nutrients: [],
            totalCarbs: 0,
            metadata: {
              created: new Date(),
              lastModified: new Date(),
              version: 1,
              calculatedBy: 'user'
            }
          }
        ]
      }

      const result = await store.importHistory(validData, 'merge')
      expect(result.imported).toBe(1)
      expect(result.errors).toHaveLength(0)
    })

    it('skips duplicates in merge mode', async () => {
      const store = useMealHistoryStore()
      // Add existing entry first
      const existingId = 'existing-entry'
      // ... add to store

      const validData: HistoryExport = {
        version: '1.0',
        exportedAt: new Date().toISOString(),
        metadata: { appVersion: '0.6.0', entryCount: 1, subjects: [] },
        entries: [
          {
            id: existingId, // Same ID as existing
            // ... rest of entry
          }
        ]
      }

      const result = await store.importHistory(validData, 'merge')
      expect(result.skipped).toBe(1)
      expect(result.imported).toBe(0)
    })

    it('replaces all entries in replace mode', async () => {
      const store = useMealHistoryStore()
      // Add existing entries
      const initialCount = store.entries.length

      const validData: HistoryExport = {
        version: '1.0',
        exportedAt: new Date().toISOString(),
        metadata: { appVersion: '0.6.0', entryCount: 2, subjects: [] },
        entries: [
          // ... 2 new entries
        ]
      }

      const result = await store.importHistory(validData, 'replace')
      expect(store.entries.length).toBe(2)
      expect(result.imported).toBe(2)
    })

    it('rejects unsupported version', async () => {
      const store = useMealHistoryStore()
      const futureData: HistoryExport = {
        version: '2.0', // Future version
        exportedAt: new Date().toISOString(),
        metadata: { appVersion: '1.0.0', entryCount: 0, subjects: [] },
        entries: []
      }

      const result = await store.importHistory(futureData, 'merge')
      expect(result.errors.length).toBeGreaterThan(0)
      expect(result.imported).toBe(0)
    })
  })
})
```

**File**: `src/utils/__tests__/fileHandling.spec.ts`

```typescript
import { describe, it, expect, vi } from 'vitest'
import { downloadJSON, readJSONFile, generateExportFilename } from '@/utils/fileHandling'

describe('fileHandling', () => {
  describe('generateExportFilename', () => {
    it('generates filename with date', () => {
      const filename = generateExportFilename('gluko-history')
      expect(filename).toMatch(/^gluko-history-\d{4}-\d{2}-\d{2}$/)
    })

    it('includes subject name', () => {
      const filename = generateExportFilename('gluko-history', 'Test Subject')
      expect(filename).toContain('Test-Subject')
    })

    it('sanitizes subject name', () => {
      const filename = generateExportFilename('gluko-history', 'Test  Subject')
      expect(filename).not.toContain('  ')
    })
  })

  describe('downloadJSON', () => {
    it('creates blob and triggers download', () => {
      const data = { test: 'data' }
      const createElementSpy = vi.spyOn(document, 'createElement')

      downloadJSON(data, 'test-file')

      expect(createElementSpy).toHaveBeenCalledWith('a')
    })
  })

  describe('readJSONFile', () => {
    it('parses valid JSON file', async () => {
      const jsonContent = JSON.stringify({ test: 'data' })
      const file = new File([jsonContent], 'test.json', { type: 'application/json' })

      const result = await readJSONFile(file)
      expect(result).toEqual({ test: 'data' })
    })

    it('rejects invalid JSON', async () => {
      const file = new File(['invalid json'], 'test.json', { type: 'application/json' })

      await expect(readJSONFile(file)).rejects.toThrow('Failed to parse JSON')
    })
  })
})
```

#### Integration Tests

**File**: `e2e/history-export-import.spec.ts`

```typescript
import { test, expect } from '@playwright/test'

test.describe('History Export/Import', () => {
  test('export downloads JSON file', async ({ page }) => {
    await page.goto('/history')

    const downloadPromise = page.waitForEvent('download')
    await page.click('button:has-text("Export")')
    const download = await downloadPromise

    expect(download.suggestedFilename()).toMatch(/gluko-history.*\.json$/)
  })

  test('import shows merge strategy dialog', async ({ page }) => {
    await page.goto('/history')

    // Upload file
    await page.click('button:has-text("Import")')
    // File chooser handling

    // Check dialog appears
    await expect(page.locator('dialog')).toBeVisible()
    await expect(page.locator('text=merge')).toBeVisible()
    await expect(page.locator('text=replace')).toBeVisible()
  })

  test('import adds entries to history', async ({ page }) => {
    // ... full import flow test
  })
})
```

---

## Phase 1: Expandable History Cards

### 1.1 Component Enhancement

**File to Modify**: `src/components/history/MealHistoryCard.vue`

**Current State**: Card shows summary only (date, total carbs, nutrient count, tags, notes)

**New State**: Card can expand to show full nutrient list in read-only mode

### 1.2 Component Implementation

```vue
<template>
  <BaseCard class="transition-transform hover:-translate-y-1">
    <!-- Existing header with timestamp and actions (unchanged) -->
    <div class="flex justify-between items-start mb-3">
      <div>
        <h2 class="text-lg font-semibold text-gray-900 dark:text-white mb-1">
          {{ formattedDate }}
        </h2>
        <p v-if="subjectName" class="text-sm text-gray-600 dark:text-gray-400">
          {{ subjectName }}
        </p>
      </div>
      <div class="relative">
        <!-- Existing menu button -->
      </div>
    </div>

    <!-- Existing summary (unchanged) -->
    <div class="flex justify-between items-center mb-3">
      <div class="flex items-center gap-4 text-sm text-gray-600 dark:text-gray-400">
        <span class="flex items-center">
          <PackageIcon class="w-4 h-4 mr-1" />
          {{ meal.nutrients.length }} {{ $t('components.mealHistoryCard.nutrients') }}
        </span>
        <span class="flex items-center">
          <TagIcon class="w-4 h-4 mr-1" />
          {{ meal.tags?.length || 0 }} {{ $t('components.mealHistoryCard.tags') }}
        </span>
      </div>
      <div>
        <span class="text-xl font-semibold text-gray-900 dark:text-white">
          {{ totalCarbs.toFixed(1) }}g
        </span>
      </div>
    </div>

    <!-- Existing tags (unchanged) -->

    <!-- Existing notes (unchanged) -->

    <!-- NEW: Expand/Collapse Button -->
    <button
      v-if="meal.nutrients.length > 0"
      type="button"
      class="mt-3 w-full flex items-center justify-center gap-2 px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-800 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2"
      :aria-expanded="expanded"
      :aria-controls="`nutrient-list-${meal.id}`"
      @click="toggleExpand"
    >
      <ChevronDownIcon
        class="w-4 h-4 transition-transform"
        :class="{ 'rotate-180': expanded }"
      />
      <span>
        {{ expanded ? $t('components.mealHistoryCard.hideDetails') : $t('components.mealHistoryCard.showDetails') }}
      </span>
    </button>

    <!-- NEW: Expandable Nutrient List -->
    <Transition
      enter-active-class="transition-all duration-200 ease-out"
      enter-from-class="opacity-0 max-h-0"
      enter-to-class="opacity-100 max-h-[1000px]"
      leave-active-class="transition-all duration-200 ease-in"
      leave-from-class="opacity-100 max-h-[1000px]"
      leave-to-class="opacity-0 max-h-0"
    >
      <div
        v-if="expanded"
        :id="`nutrient-list-${meal.id}`"
        class="mt-3 overflow-hidden"
      >
        <div class="border-t border-gray-200 dark:border-gray-700 pt-3">
          <h3 class="text-sm font-semibold text-gray-900 dark:text-white mb-2">
            {{ $t('components.mealHistoryCard.nutrientDetails') }}
          </h3>
          <div class="space-y-2">
            <NutrientListItem
              v-for="(nutrient, index) in meal.nutrients"
              :key="`${meal.id}-nutrient-${index}`"
              :nutrient="nutrient"
              :index="index"
            />
          </div>
          
          <!-- Total row -->
          <div class="mt-3 pt-3 border-t border-gray-200 dark:border-gray-700 flex justify-between items-center font-semibold text-gray-900 dark:text-white">
            <span>{{ $t('components.mealHistoryCard.total') }}</span>
            <span>{{ totalCarbs.toFixed(1) }}g {{ $t('components.mealHistoryCard.carbs') }}</span>
          </div>
        </div>
      </div>
    </Transition>
  </BaseCard>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import { useSubjectStore } from '@/stores/subject'
import type { MealHistoryEntry } from '@/types/meal-history'
import BaseCard from '@/components/base/BaseCard.vue'
import NutrientListItem from '@/components/history/NutrientListItem.vue'
import {
  MoreVerticalIcon,
  PencilIcon,
  CopyIcon,
  Trash2Icon,
  PackageIcon,
  TagIcon,
  ChevronDownIcon
} from 'lucide-vue-next'

interface Props {
  meal: MealHistoryEntry
}

const props = defineProps<Props>()
const subjectStore = useSubjectStore()

defineEmits(['edit', 'duplicate', 'delete'])

const showMenu = ref(false)
const expanded = ref(false)

// Existing computed properties...

function toggleExpand() {
  expanded.value = !expanded.value
}
</script>

<style scoped>
/* Respect reduced motion preference */
@media (prefers-reduced-motion: reduce) {
  .transition-transform,
  .transition-all,
  button {
    transition: none !important;
  }
  
  .rotate-180 {
    transform: none;
  }
}
</style>
```

### 1.3 New Component: NutrientListItem

**File**: `src/components/history/NutrientListItem.vue`

```vue
<template>
  <div class="flex items-start gap-3 p-2 rounded-lg bg-gray-50 dark:bg-gray-800/50">
    <div class="flex-shrink-0 flex items-center justify-center w-6 h-6 rounded-full bg-primary-100 dark:bg-primary-900 text-xs font-medium text-primary-700 dark:text-primary-300">
      {{ index + 1 }}
    </div>
    <div class="flex-1 min-w-0">
      <p class="text-sm font-medium text-gray-900 dark:text-white truncate">
        {{ nutrient.name }}
      </p>
      <p class="text-xs text-gray-600 dark:text-gray-400">
        {{ nutrient.quantity }}g × {{ nutrient.factor }} = 
        <span class="font-medium">{{ carbValue.toFixed(1) }}g</span>
      </p>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import type { Nutrient } from '@/stores/meal'

interface Props {
  nutrient: Nutrient
  index: number
}

const props = defineProps<Props>()

const carbValue = computed(() => props.nutrient.quantity * props.nutrient.factor)
</script>
```

### 1.4 i18n Strings

**Add to**: `src/i18n/locales/en.json` and `src/i18n/locales/fr.json`

```json
{
  "components": {
    "mealHistoryCard": {
      "showDetails": "Show details",
      "hideDetails": "Hide details",
      "nutrientDetails": "Nutrient Details",
      "total": "Total",
      "carbs": "carbs"
    }
  }
}
```

```json
{
  "components": {
    "mealHistoryCard": {
      "showDetails": "Afficher les détails",
      "hideDetails": "Masquer les détails",
      "nutrientDetails": "Détails des nutriments",
      "total": "Total",
      "carbs": "glucides"
    }
  }
}
```

### 1.5 Accessibility Requirements

#### Keyboard Navigation

- **Tab**: Focus expand/collapse button
- **Enter/Space**: Toggle expand/collapse
- **Focus indicator**: 2px ring around button when focused

#### Screen Reader Support

- `aria-expanded`: Indicates expanded/collapsed state
- `aria-controls`: Links button to controlled content region
- Dynamic button text: "Show details" / "Hide details" announced on change
- Nutrient list announced as "list of N items" when expanded

#### ARIA Implementation

```vue
<!-- Button -->
<button
  type="button"
  :aria-expanded="expanded"
  :aria-controls="`nutrient-list-${meal.id}`"
  aria-label="Show nutrient details"
>

<!-- Expandable region -->
<div
  :id="`nutrient-list-${meal.id}`"
  role="region"
  :aria-label="$t('components.mealHistoryCard.nutrientDetails')"
>
  <ul role="list" class="space-y-2">
    <li v-for="(nutrient, index) in meal.nutrients" :key="index">
      <NutrientListItem :nutrient="nutrient" :index="index" />
    </li>
  </ul>
</div>
```

### 1.6 Animation Considerations

**Smooth Expand/Collapse**:
- Use Vue `<Transition>` component with Tailwind classes
- Duration: 200ms (quick but noticeable)
- Easing: `ease-out` for expand, `ease-in` for collapse
- Respect `prefers-reduced-motion` media query

**Height Animation**:
- Use `max-h-[1000px]` trick (large enough for content, but finite)
- Alternative: Dynamic height calculation with `scrollHeight`

```vue
<Transition
  @before-enter="beforeEnter"
  @enter="enter"
  @leave="leave"
>
  <div v-if="expanded" ref="contentRef">
    <!-- Nutrient list -->
  </div>
</Transition>

<script setup>
function beforeEnter(el) {
  el.style.height = '0'
}

function enter(el) {
  el.style.height = el.scrollHeight + 'px'
}

function leave(el) {
  el.style.height = '0'
}
</script>
```

### 1.7 Testing Requirements

#### Unit Tests

**File**: `src/components/history/__tests__/MealHistoryCard.spec.ts`

```typescript
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import MealHistoryCard from '../MealHistoryCard.vue'
import type { MealHistoryEntry } from '@/types/meal-history'

describe('MealHistoryCard - Expandable', () => {
  const mockMeal: MealHistoryEntry = {
    id: 'test-meal',
    subjectId: 'test-subject',
    date: new Date('2025-12-20'),
    tags: ['breakfast'],
    nutrients: [
      { id: '1', name: 'Oatmeal', quantity: 100, factor: 0.6 },
      { id: '2', name: 'Banana', quantity: 120, factor: 0.23 }
    ],
    totalCarbs: 87.6,
    metadata: {
      created: new Date(),
      lastModified: new Date(),
      version: 1,
      calculatedBy: 'user'
    }
  }

  it('renders expand button when nutrients exist', () => {
    const wrapper = mount(MealHistoryCard, {
      props: { meal: mockMeal }
    })

    expect(wrapper.find('button[aria-expanded]').exists()).toBe(true)
  })

  it('does not render expand button when no nutrients', () => {
    const emptyMeal = { ...mockMeal, nutrients: [] }
    const wrapper = mount(MealHistoryCard, {
      props: { meal: emptyMeal }
    })

    expect(wrapper.find('button[aria-expanded]').exists()).toBe(false)
  })

  it('toggles expanded state on button click', async () => {
    const wrapper = mount(MealHistoryCard, {
      props: { meal: mockMeal }
    })

    const button = wrapper.find('button[aria-expanded]')
    expect(button.attributes('aria-expanded')).toBe('false')

    await button.trigger('click')
    expect(button.attributes('aria-expanded')).toBe('true')

    await button.trigger('click')
    expect(button.attributes('aria-expanded')).toBe('false')
  })

  it('shows nutrient list when expanded', async () => {
    const wrapper = mount(MealHistoryCard, {
      props: { meal: mockMeal }
    })

    // Initially collapsed
    expect(wrapper.find('[id^="nutrient-list-"]').exists()).toBe(false)

    // Expand
    await wrapper.find('button[aria-expanded]').trigger('click')
    await wrapper.vm.$nextTick()

    // Now visible
    expect(wrapper.find('[id^="nutrient-list-"]').exists()).toBe(true)
  })

  it('renders all nutrients in list', async () => {
    const wrapper = mount(MealHistoryCard, {
      props: { meal: mockMeal }
    })

    await wrapper.find('button[aria-expanded]').trigger('click')
    await wrapper.vm.$nextTick()

    const nutrientItems = wrapper.findAllComponents({ name: 'NutrientListItem' })
    expect(nutrientItems).toHaveLength(2)
  })

  it('updates button text when toggling', async () => {
    const wrapper = mount(MealHistoryCard, {
      props: { meal: mockMeal }
    })

    const button = wrapper.find('button[aria-expanded]')
    expect(button.text()).toContain('Show details')

    await button.trigger('click')
    expect(button.text()).toContain('Hide details')
  })

  it('respects prefers-reduced-motion', () => {
    // Set reduced motion preference
    window.matchMedia = vi.fn().mockImplementation(query => ({
      matches: query === '(prefers-reduced-motion: reduce)',
      media: query,
      addEventListener: vi.fn(),
      removeEventListener: vi.fn()
    }))

    const wrapper = mount(MealHistoryCard, {
      props: { meal: mockMeal }
    })

    // Check that transitions are disabled via CSS
    // (This is a style test, might need different approach)
  })
})
```

**File**: `src/components/history/__tests__/NutrientListItem.spec.ts`

```typescript
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import NutrientListItem from '../NutrientListItem.vue'

describe('NutrientListItem', () => {
  const mockNutrient = {
    id: '1',
    name: 'Oatmeal',
    quantity: 100,
    factor: 0.6
  }

  it('renders nutrient name', () => {
    const wrapper = mount(NutrientListItem, {
      props: { nutrient: mockNutrient, index: 0 }
    })

    expect(wrapper.text()).toContain('Oatmeal')
  })

  it('displays correct calculation', () => {
    const wrapper = mount(NutrientListItem, {
      props: { nutrient: mockNutrient, index: 0 }
    })

    expect(wrapper.text()).toContain('100g × 0.6 = 60.0g')
  })

  it('shows index number', () => {
    const wrapper = mount(NutrientListItem, {
      props: { nutrient: mockNutrient, index: 2 }
    })

    expect(wrapper.text()).toContain('3') // index + 1
  })

  it('calculates carb value correctly', () => {
    const nutrient = { id: '2', name: 'Banana', quantity: 120, factor: 0.23 }
    const wrapper = mount(NutrientListItem, {
      props: { nutrient, index: 0 }
    })

    expect(wrapper.text()).toContain('27.6g')
  })
})
```

#### E2E Tests

**File**: `e2e/history-expandable.spec.ts`

```typescript
import { test, expect } from '@playwright/test'

test.describe('History Card Expansion', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/history')
    // Ensure at least one history entry exists
  })

  test('expand button shows nutrient details', async ({ page }) => {
    const card = page.locator('.meal-history-card').first()
    const expandButton = card.locator('button[aria-expanded]')

    await expect(expandButton).toBeVisible()
    await expect(expandButton).toHaveAttribute('aria-expanded', 'false')

    await expandButton.click()

    await expect(expandButton).toHaveAttribute('aria-expanded', 'true')
    await expect(card.locator('[id^="nutrient-list-"]')).toBeVisible()
  })

  test('shows all nutrients when expanded', async ({ page }) => {
    const card = page.locator('.meal-history-card').first()
    await card.locator('button[aria-expanded]').click()

    const nutrientItems = card.locator('.nutrient-list-item')
    await expect(nutrientItems.first()).toBeVisible()
  })

  test('keyboard navigation works', async ({ page }) => {
    await page.keyboard.press('Tab') // Navigate to first expand button
    await page.keyboard.press('Enter') // Expand

    const expandedRegion = page.locator('[id^="nutrient-list-"]').first()
    await expect(expandedRegion).toBeVisible()
  })

  test('collapse hides nutrient details', async ({ page }) => {
    const card = page.locator('.meal-history-card').first()
    const expandButton = card.locator('button[aria-expanded]')

    // Expand
    await expandButton.click()
    await expect(card.locator('[id^="nutrient-list-"]')).toBeVisible()

    // Collapse
    await expandButton.click()
    await expect(card.locator('[id^="nutrient-list-"]')).not.toBeVisible()
  })
})
```

### 1.8 Success Criteria

- [ ] Expand button appears on cards with nutrients
- [ ] Clicking expand shows full nutrient list
- [ ] Each nutrient displays: name, quantity, factor, calculated carbs
- [ ] Total row matches card summary
- [ ] Collapse hides nutrient list
- [ ] Smooth animation (200ms) respects `prefers-reduced-motion`
- [ ] Keyboard accessible (Tab, Enter, Space)
- [ ] Screen reader announces state changes
- [ ] Button text changes ("Show details" / "Hide details")
- [ ] Multiple cards can be expanded simultaneously
- [ ] No layout shift when expanding/collapsing

---

## Phase 2: Edit via Calculator with Safeguards

### 2.1 Architecture: View Isolation

**Key Principle**: History view and Calculator view communicate ONLY through stores, never direct imports.

```
┌─────────────────┐         ┌──────────────────┐         ┌─────────────────┐
│  History View   │────────>│  Pinia Stores    │<────────│ Calculator View │
│  (read/display) │         │  (shared state)  │         │  (edit/create)  │
└─────────────────┘         └──────────────────┘         └─────────────────┘
                                     │
                                     ├─ useMealStore
                                     │  - hasUnsavedChanges
                                     │  - loadFromHistory()
                                     │  - editingHistoryId
                                     │
                                     └─ useMealHistoryStore
                                        - entries
                                        - updateEntry()
```

**Communication Flow**:
1. User clicks "Edit" in History view
2. History view calls `router.push('/calculator', { query: { historyId: 'xxx' } })`
3. Calculator view reads `route.query.historyId` on mount
4. Calculator calls `mealStore.loadFromHistory(historyId)`
5. Meal store loads data from history store
6. No direct dependency between views

### 2.2 Dirty State Tracking (useMealStore)

**Implementation**: `src/stores/meal.ts`

```typescript
// Add new state
const editingHistoryId = ref<string | null>(null)
const initialNutrientsHash = ref<string | null>(null)

// Helper: Create hash of nutrients array for comparison
function hashNutrients(nutrients: Nutrient[]): string {
  return JSON.stringify(
    nutrients.map(n => ({ id: n.id, quantity: n.quantity, factor: n.factor }))
  )
}

// Computed: Check if current session has unsaved changes
const hasUnsavedChanges = computed(() => {
  const session = getCurrentSession()
  if (!session || session.nutrients.length === 0) return false
  
  // Compare current state to initial state
  const currentHash = hashNutrients(session.nutrients)
  return initialNutrientsHash.value !== currentHash
})

// Action: Set initial hash when session starts/loads
function setInitialHash() {
  const session = getCurrentSession()
  if (session) {
    initialNutrientsHash.value = hashNutrients(session.nutrients)
  } else {
    initialNutrientsHash.value = null
  }
}

// Update existing addNutrient, removeNutrient, etc. to NOT update hash
// (we only update hash on explicit actions: save, load, clear)

// Action: Load history entry into calculator
async function loadFromHistory(
  historyId: string,
  options?: { skipConfirmation?: boolean }
): Promise<{ success: boolean; reason?: string }> {
  // Check for unsaved changes
  if (!options?.skipConfirmation && hasUnsavedChanges.value) {
    return {
      success: false,
      reason: 'unsaved-changes'
    }
  }

  try {
    // Get history entry
    const entry = await db.getMealHistory(historyId)
    if (!entry) {
      throw new Error(`History entry not found: ${historyId}`)
    }

    // Ensure subject matches or switch subject
    if (subjectStore.activeSubjectId !== entry.subjectId) {
      await subjectStore.setActiveSubject(entry.subjectId)
    }

    // Clear current session
    await clearMeal()

    // Load nutrients from history
    const session = getCurrentSession()
    if (!session) {
      throw new Error('No active session after clear')
    }

    // Deep copy nutrients to avoid mutation
    session.nutrients = entry.nutrients.map(n => ({ ...n }))
    session.lastModified = new Date()

    // Set editing mode
    editingHistoryId.value = historyId
    
    // Save to IndexedDB
    await db.saveActiveSession(session)

    // Set initial hash to track future changes
    setInitialHash()

    return { success: true }
  } catch (err) {
    console.error('Failed to load history entry:', err)
    return {
      success: false,
      reason: err instanceof Error ? err.message : 'unknown-error'
    }
  }
}

// Action: Save current meal (update history if editing, create new otherwise)
async function saveMeal(options?: {
  name?: string
  notes?: string
  tags?: string[]
}): Promise<{ success: boolean; entryId?: string }> {
  const session = getCurrentSession()
  if (!session || session.nutrients.length === 0) {
    return { success: false }
  }

  try {
    const now = new Date()
    
    // If editing existing entry, update it
    if (editingHistoryId.value) {
      const existingEntry = await db.getMealHistory(editingHistoryId.value)
      if (existingEntry) {
        const updatedEntry: MealHistoryEntry = {
          ...existingEntry,
          nutrients: session.nutrients,
          totalCarbs: mealCarbs.value,
          name: options?.name ?? existingEntry.name,
          notes: options?.notes ?? existingEntry.notes,
          tags: options?.tags ?? existingEntry.tags,
          metadata: {
            ...existingEntry.metadata,
            lastModified: now,
            version: existingEntry.metadata.version + 1
          }
        }
        
        await db.saveMealHistory(updatedEntry)
        
        // Update local history store
        const historyStore = useMealHistoryStore()
        historyStore.updateEntry(updatedEntry)
        
        // Clear editing mode
        editingHistoryId.value = null
        setInitialHash() // Reset dirty state
        
        return { success: true, entryId: updatedEntry.id }
      }
    }
    
    // Otherwise, create new entry
    const newEntry: MealHistoryEntry = {
      id: getUUID(),
      subjectId: session.subjectId,
      date: now,
      name: options?.name,
      notes: options?.notes,
      tags: options?.tags || [],
      nutrients: session.nutrients,
      totalCarbs: mealCarbs.value,
      metadata: {
        created: now,
        lastModified: now,
        version: 1,
        calculatedBy: 'user',
        createdFrom: session.id
      }
    }
    
    await db.saveMealHistory(newEntry)
    
    // Add to history store
    const historyStore = useMealHistoryStore()
    historyStore.addEntry(newEntry)
    
    // Clear calculator
    await clearMeal()
    
    return { success: true, entryId: newEntry.id }
  } catch (err) {
    console.error('Failed to save meal:', err)
    return { success: false }
  }
}

// Action: Discard current changes and optionally load history
async function discardAndLoad(historyId?: string): Promise<boolean> {
  await clearMeal()
  initialNutrientsHash.value = null
  editingHistoryId.value = null
  
  if (historyId) {
    const result = await loadFromHistory(historyId, { skipConfirmation: true })
    return result.success
  }
  
  return true
}

// Action: Save current then load history
async function saveAndLoad(
  historyId: string,
  saveOptions?: { name?: string; notes?: string; tags?: string[] }
): Promise<boolean> {
  const saveResult = await saveMeal(saveOptions)
  if (!saveResult.success) return false
  
  const loadResult = await loadFromHistory(historyId, { skipConfirmation: true })
  return loadResult.success
}

// Export new getters and actions
return {
  // ... existing exports
  hasUnsavedChanges,
  editingHistoryId: computed(() => editingHistoryId.value),
  loadFromHistory,
  discardAndLoad,
  saveAndLoad
}
```

### 2.3 History Store Updates (useMealHistoryStore)

**Implementation**: `src/stores/mealHistory.ts`

```typescript
// Add action to update existing entry
const updateEntry = (updatedEntry: MealHistoryEntry) => {
  const index = entries.value.findIndex(e => e.id === updatedEntry.id)
  if (index !== -1) {
    entries.value[index] = updatedEntry
    // Re-sort if date changed
    entries.value.sort((a, b) => b.date.getTime() - a.date.getTime())
  }
}

// Add action to add new entry
const addEntry = (newEntry: MealHistoryEntry) => {
  entries.value.push(newEntry)
  entries.value.sort((a, b) => b.date.getTime() - a.date.getTime())
}

// Export
return {
  // ... existing exports
  updateEntry,
  addEntry
}
```

### 2.4 Confirmation Dialog Component

**New File**: `src/components/dialogs/UnsavedChangesDialog.vue`

```vue
<template>
  <BaseDialog :open="open" @close="handleCancel">
    <template #title>
      {{ $t('dialogs.unsavedChanges.title') }}
    </template>

    <div class="space-y-4">
      <div class="flex items-start gap-3 p-3 rounded-lg bg-warning-50 dark:bg-warning-900/20 border border-warning-200 dark:border-warning-800">
        <AlertTriangleIcon class="w-5 h-5 text-warning-600 dark:text-warning-400 flex-shrink-0 mt-0.5" />
        <div>
          <p class="text-sm font-medium text-warning-900 dark:text-warning-100">
            {{ $t('dialogs.unsavedChanges.message') }}
          </p>
          <p class="text-sm text-warning-700 dark:text-warning-300 mt-1">
            {{ $t('dialogs.unsavedChanges.description') }}
          </p>
        </div>
      </div>

      <!-- Current calculation summary -->
      <div v-if="currentNutrientCount > 0" class="p-3 rounded-lg bg-gray-50 dark:bg-gray-800 border border-gray-200 dark:border-gray-700">
        <p class="text-sm text-gray-600 dark:text-gray-400">
          {{ $t('dialogs.unsavedChanges.currentCalculation') }}
        </p>
        <p class="text-base font-semibold text-gray-900 dark:text-white mt-1">
          {{ currentNutrientCount }} {{ $t('dialogs.unsavedChanges.nutrients') }} • 
          {{ currentTotalCarbs.toFixed(1) }}g {{ $t('dialogs.unsavedChanges.carbs') }}
        </p>
      </div>
    </div>

    <template #actions>
      <div class="flex flex-col gap-2 w-full sm:flex-row-reverse">
        <!-- Save & Load -->
        <BaseButton
          variant="primary"
          class="w-full sm:w-auto"
          @click="handleSaveAndLoad"
        >
          <SaveIcon class="w-4 h-4 mr-2" />
          {{ $t('dialogs.unsavedChanges.actions.saveAndLoad') }}
        </BaseButton>
        
        <!-- Discard & Load -->
        <BaseButton
          variant="danger"
          class="w-full sm:w-auto"
          @click="handleDiscardAndLoad"
        >
          <Trash2Icon class="w-4 h-4 mr-2" />
          {{ $t('dialogs.unsavedChanges.actions.discardAndLoad') }}
        </BaseButton>
        
        <!-- Cancel -->
        <BaseButton
          variant="secondary"
          class="w-full sm:w-auto"
          @click="handleCancel"
        >
          {{ $t('common.cancel') }}
        </BaseButton>
      </div>
    </template>
  </BaseDialog>
</template>

<script setup lang="ts">
import BaseDialog from '@/components/base/BaseDialog.vue'
import BaseButton from '@/components/base/BaseButton.vue'
import { AlertTriangleIcon, SaveIcon, Trash2Icon } from 'lucide-vue-next'

interface Props {
  open: boolean
  currentNutrientCount: number
  currentTotalCarbs: number
}

defineProps<Props>()

const emit = defineEmits<{
  saveAndLoad: []
  discardAndLoad: []
  cancel: []
}>()

function handleSaveAndLoad() {
  emit('saveAndLoad')
}

function handleDiscardAndLoad() {
  emit('discardAndLoad')
}

function handleCancel() {
  emit('cancel')
}
</script>
```

### 2.5 History View Integration

**Updates**: `src/views/MealHistoryView.vue`

```typescript
// Add state for unsaved changes dialog
const showUnsavedDialog = ref(false)
const pendingHistoryId = ref<string | null>(null)

// Update handleEditMeal to check for unsaved changes
async function handleEditMeal(meal: MealHistoryEntry) {
  const mealStore = useMealStore()
  
  // Attempt to load (will return false if unsaved changes)
  const result = await mealStore.loadFromHistory(meal.id)
  
  if (!result.success && result.reason === 'unsaved-changes') {
    // Show confirmation dialog
    pendingHistoryId.value = meal.id
    showUnsavedDialog.value = true
  } else if (result.success) {
    // Navigate to calculator
    router.push('/calculator')
  } else {
    // Show error
    error.value = result.reason || 'Failed to load meal'
  }
}

// Handle dialog actions
async function handleSaveAndLoad() {
  if (!pendingHistoryId.value) return
  
  const mealStore = useMealStore()
  const success = await mealStore.saveAndLoad(pendingHistoryId.value)
  
  showUnsavedDialog.value = false
  
  if (success) {
    router.push('/calculator')
  } else {
    error.value = 'Failed to save and load meal'
  }
  
  pendingHistoryId.value = null
}

async function handleDiscardAndLoad() {
  if (!pendingHistoryId.value) return
  
  const mealStore = useMealStore()
  const success = await mealStore.discardAndLoad(pendingHistoryId.value)
  
  showUnsavedDialog.value = false
  
  if (success) {
    router.push('/calculator')
  }
  
  pendingHistoryId.value = null
}

function handleCancelDialog() {
  showUnsavedDialog.value = false
  pendingHistoryId.value = null
}
```

```vue
<!-- Add dialog to template -->
<UnsavedChangesDialog
  :open="showUnsavedDialog"
  :current-nutrient-count="mealStore.nutrientCount"
  :current-total-carbs="mealStore.mealCarbs"
  @save-and-load="handleSaveAndLoad"
  @discard-and-load="handleDiscardAndLoad"
  @cancel="handleCancelDialog"
/>
```

### 2.6 Calculator View Integration

**Updates**: `src/views/CalculatorView.vue` (or similar)

```typescript
import { onMounted, computed } from 'vue'
import { useRoute } from 'vue-router'
import { useMealStore } from '@/stores/meal'

const route = useRoute()
const mealStore = useMealStore()

// Check if editing mode
const isEditingHistory = computed(() => mealStore.editingHistoryId !== null)

onMounted(async () => {
  // Check if we should load a history entry
  const historyId = route.query.historyId as string | undefined
  
  if (historyId) {
    const result = await mealStore.loadFromHistory(historyId)
    
    if (!result.success) {
      // Show error toast
      console.error('Failed to load history entry:', result.reason)
    }
  }
})
```

```vue
<!-- Add edit mode indicator in template -->
<div v-if="isEditingHistory" class="mb-4 p-3 rounded-lg bg-info-50 dark:bg-info-900/20 border border-info-200 dark:border-info-800">
  <div class="flex items-center gap-2">
    <PencilIcon class="w-5 h-5 text-info-600 dark:text-info-400" />
    <p class="text-sm font-medium text-info-900 dark:text-info-100">
      {{ $t('views.calculator.editingHistory') }}
    </p>
  </div>
</div>
```

### 2.7 Route Guards (Optional, for navigation protection)

**File**: `src/router/guards.ts`

```typescript
import type { NavigationGuardNext, RouteLocationNormalized } from 'vue-router'
import { useMealStore } from '@/stores/meal'

export function unsavedChangesGuard(
  to: RouteLocationNormalized,
  from: RouteLocationNormalized,
  next: NavigationGuardNext
) {
  // Only guard when leaving calculator
  if (from.path !== '/calculator') {
    next()
    return
  }

  const mealStore = useMealStore()
  
  // Check for unsaved changes
  if (mealStore.hasUnsavedChanges) {
    // Show browser confirm dialog (or custom modal)
    const confirmed = window.confirm(
      'You have unsaved changes. Are you sure you want to leave?'
    )
    
    if (confirmed) {
      next()
    } else {
      next(false)
    }
  } else {
    next()
  }
}
```

**Usage**: `src/router/index.ts`

```typescript
import { unsavedChangesGuard } from './guards'

const router = createRouter({
  // ... routes
})

router.beforeEach(unsavedChangesGuard)
```

### 2.8 i18n Strings

```json
{
  "dialogs": {
    "unsavedChanges": {
      "title": "Unsaved Changes",
      "message": "You have unsaved changes in your current calculation",
      "description": "What would you like to do with your current work?",
      "currentCalculation": "Current calculation:",
      "nutrients": "nutrients",
      "carbs": "carbs",
      "actions": {
        "saveAndLoad": "Save & Load",
        "discardAndLoad": "Discard & Load"
      }
    }
  },
  "views": {
    "calculator": {
      "editingHistory": "Editing saved meal"
    }
  }
}
```

### 2.9 Testing Requirements

**Unit Tests**: `src/stores/__tests__/meal.dirtyState.spec.ts`

```typescript
describe('meal store - dirty state tracking', () => {
  it('hasUnsavedChanges is false initially', () => {
    const store = useMealStore()
    expect(store.hasUnsavedChanges).toBe(false)
  })

  it('hasUnsavedChanges is true after adding nutrient', async () => {
    const store = useMealStore()
    await store.addNutrient({ id: '1', name: 'Test', quantity: 100, factor: 0.5 })
    expect(store.hasUnsavedChanges).toBe(true)
  })

  it('loadFromHistory sets editingHistoryId', async () => {
    const store = useMealStore()
    // Create test history entry
    const result = await store.loadFromHistory('test-id', { skipConfirmation: true })
    expect(store.editingHistoryId).toBe('test-id')
  })

  it('loadFromHistory returns unsaved-changes reason when dirty', async () => {
    const store = useMealStore()
    await store.addNutrient({ id: '1', name: 'Test', quantity: 100, factor: 0.5 })
    
    const result = await store.loadFromHistory('test-id')
    expect(result.success).toBe(false)
    expect(result.reason).toBe('unsaved-changes')
  })

  it('saveMeal updates existing entry when editing', async () => {
    const store = useMealStore()
    const historyStore = useMealHistoryStore()
    
    // Load existing entry
    await store.loadFromHistory('existing-id', { skipConfirmation: true })
    
    // Modify
    await store.addNutrient({ id: '2', name: 'New', quantity: 50, factor: 0.3 })
    
    // Save
    const result = await store.saveMeal()
    expect(result.success).toBe(true)
    
    // Check entry was updated, not created
    const updated = historyStore.entries.find(e => e.id === 'existing-id')
    expect(updated).toBeDefined()
    expect(updated!.metadata.version).toBe(2)
  })
})
```

### 2.10 Success Criteria

- [ ] `hasUnsavedChanges` correctly detects modifications
- [ ] `loadFromHistory` returns error when unsaved changes exist
- [ ] Confirmation dialog shows with 3 options (save, discard, cancel)
- [ ] "Save & Load" saves current work then loads history entry
- [ ] "Discard & Load" clears current work then loads history entry
- [ ] "Cancel" closes dialog without action
- [ ] Calculator shows "Editing saved meal" indicator when editing
- [ ] Saving edited entry updates existing record (doesn't create duplicate)
- [ ] Route guard prevents accidental navigation loss
- [ ] Dialog accessible (keyboard nav, ARIA, screen reader)
- [ ] Works correctly when navigating directly via URL query param

---

## Phase 3: UX Polish

### 3.1 Toast Notification System

**New Composable**: `src/composables/useToast.ts`

```typescript
import { ref, computed } from 'vue'

export interface Toast {
  id: string
  message: string
  variant: 'success' | 'error' | 'warning' | 'info'
  duration?: number // milliseconds, default 5000
  action?: {
    label: string
    onClick: () => void
  }
}

const toasts = ref<Toast[]>([])
let toastIdCounter = 0

export function useToast() {
  const show = (toast: Omit<Toast, 'id'>): string => {
    const id = `toast-${++toastIdCounter}`
    const newToast: Toast = {
      id,
      duration: 5000,
      ...toast
    }
    
    toasts.value.push(newToast)
    
    // Auto-dismiss after duration
    if (newToast.duration && newToast.duration > 0) {
      setTimeout(() => {
        dismiss(id)
      }, newToast.duration)
    }
    
    return id
  }
  
  const dismiss = (id: string) => {
    const index = toasts.value.findIndex(t => t.id === id)
    if (index !== -1) {
      toasts.value.splice(index, 1)
    }
  }
  
  const dismissAll = () => {
    toasts.value = []
  }
  
  // Convenience methods
  const success = (message: string, options?: Partial<Toast>) => 
    show({ message, variant: 'success', ...options })
  
  const error = (message: string, options?: Partial<Toast>) => 
    show({ message, variant: 'error', ...options })
  
  const warning = (message: string, options?: Partial<Toast>) => 
    show({ message, variant: 'warning', ...options })
  
  const info = (message: string, options?: Partial<Toast>) => 
    show({ message, variant: 'info', ...options })
  
  return {
    toasts: computed(() => toasts.value),
    show,
    dismiss,
    dismissAll,
    success,
    error,
    warning,
    info
  }
}
```

**Toast Container Component**: `src/components/base/ToastContainer.vue`

```vue
<template>
  <Teleport to="body">
    <div
      class="fixed bottom-0 right-0 z-50 p-4 space-y-2 pointer-events-none"
      aria-live="polite"
      aria-atomic="true"
    >
      <TransitionGroup
        enter-active-class="transition-all duration-300 ease-out"
        enter-from-class="translate-y-2 opacity-0"
        enter-to-class="translate-y-0 opacity-100"
        leave-active-class="transition-all duration-200 ease-in"
        leave-from-class="translate-y-0 opacity-100"
        leave-to-class="translate-y-2 opacity-0"
      >
        <Toast
          v-for="toast in toasts"
          :key="toast.id"
          :toast="toast"
          class="pointer-events-auto"
          @dismiss="handleDismiss(toast.id)"
        />
      </TransitionGroup>
    </div>
  </Teleport>
</template>

<script setup lang="ts">
import { useToast } from '@/composables/useToast'
import Toast from './Toast.vue'

const { toasts, dismiss } = useToast()

function handleDismiss(id: string) {
  dismiss(id)
}
</script>
```

**Toast Component**: `src/components/base/Toast.vue`

```vue
<template>
  <div
    role="alert"
    class="min-w-[320px] max-w-md rounded-lg shadow-lg border pointer-events-auto"
    :class="variantClasses"
  >
    <div class="flex items-start gap-3 p-4">
      <!-- Icon -->
      <component
        :is="iconComponent"
        class="w-5 h-5 flex-shrink-0 mt-0.5"
        :class="iconClasses"
      />
      
      <!-- Message -->
      <p class="flex-1 text-sm font-medium" :class="textClasses">
        {{ toast.message }}
      </p>
      
      <!-- Action button -->
      <button
        v-if="toast.action"
        type="button"
        class="text-sm font-medium underline hover:no-underline focus:outline-none focus:ring-2 focus:ring-offset-2 rounded"
        :class="actionClasses"
        @click="handleAction"
      >
        {{ toast.action.label }}
      </button>
      
      <!-- Dismiss button -->
      <button
        type="button"
        class="flex-shrink-0 rounded-lg p-1 hover:bg-black/5 dark:hover:bg-white/5 focus:outline-none focus:ring-2 focus:ring-offset-2"
        :class="dismissClasses"
        @click="$emit('dismiss')"
      >
        <XIcon class="w-4 h-4" />
        <span class="sr-only">Dismiss</span>
      </button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import type { Toast as ToastType } from '@/composables/useToast'
import {
  CheckCircleIcon,
  AlertCircleIcon,
  AlertTriangleIcon,
  InfoIcon,
  XIcon
} from 'lucide-vue-next'

interface Props {
  toast: ToastType
}

const props = defineProps<Props>()
const emit = defineEmits(['dismiss'])

const iconComponent = computed(() => {
  switch (props.toast.variant) {
    case 'success': return CheckCircleIcon
    case 'error': return AlertCircleIcon
    case 'warning': return AlertTriangleIcon
    case 'info': return InfoIcon
    default: return InfoIcon
  }
})

const variantClasses = computed(() => {
  switch (props.toast.variant) {
    case 'success':
      return 'bg-success-50 dark:bg-success-900/20 border-success-200 dark:border-success-800'
    case 'error':
      return 'bg-danger-50 dark:bg-danger-900/20 border-danger-200 dark:border-danger-800'
    case 'warning':
      return 'bg-warning-50 dark:bg-warning-900/20 border-warning-200 dark:border-warning-800'
    case 'info':
      return 'bg-info-50 dark:bg-info-900/20 border-info-200 dark:border-info-800'
    default:
      return 'bg-gray-50 dark:bg-gray-800 border-gray-200 dark:border-gray-700'
  }
})

const iconClasses = computed(() => {
  switch (props.toast.variant) {
    case 'success': return 'text-success-600 dark:text-success-400'
    case 'error': return 'text-danger-600 dark:text-danger-400'
    case 'warning': return 'text-warning-600 dark:text-warning-400'
    case 'info': return 'text-info-600 dark:text-info-400'
    default: return 'text-gray-600 dark:text-gray-400'
  }
})

const textClasses = computed(() => {
  switch (props.toast.variant) {
    case 'success': return 'text-success-900 dark:text-success-100'
    case 'error': return 'text-danger-900 dark:text-danger-100'
    case 'warning': return 'text-warning-900 dark:text-warning-100'
    case 'info': return 'text-info-900 dark:text-info-100'
    default: return 'text-gray-900 dark:text-gray-100'
  }
})

const actionClasses = computed(() => {
  switch (props.toast.variant) {
    case 'success': return 'text-success-700 dark:text-success-300 focus:ring-success-500'
    case 'error': return 'text-danger-700 dark:text-danger-300 focus:ring-danger-500'
    case 'warning': return 'text-warning-700 dark:text-warning-300 focus:ring-warning-500'
    case 'info': return 'text-info-700 dark:text-info-300 focus:ring-info-500'
    default: return 'text-gray-700 dark:text-gray-300 focus:ring-gray-500'
  }
})

const dismissClasses = computed(() => {
  switch (props.toast.variant) {
    case 'success': return 'text-success-600 dark:text-success-400 focus:ring-success-500'
    case 'error': return 'text-danger-600 dark:text-danger-400 focus:ring-danger-500'
    case 'warning': return 'text-warning-600 dark:text-warning-400 focus:ring-warning-500'
    case 'info': return 'text-info-600 dark:text-info-400 focus:ring-info-500'
    default: return 'text-gray-600 dark:text-gray-400 focus:ring-gray-500'
  }
})

function handleAction() {
  props.toast.action?.onClick()
  emit('dismiss')
}
</script>
```

### 3.2 Toast Integration in Views

**History View**: Success/error toasts for export/import

```typescript
import { useToast } from '@/composables/useToast'

const toast = useToast()

// Export success
function handleExport() {
  try {
    const exportData = mealHistoryStore.exportHistory()
    const filename = generateExportFilename('gluko-history', subjectStore.currentSubject?.name)
    downloadJSON(exportData, filename)
    
    toast.success(
      $t('toasts.history.exportSuccess', { count: exportData.metadata.entryCount })
    )
  } catch (err) {
    toast.error($t('toasts.history.exportError'))
  }
}

// Import success
async function handleImportConfirm(strategy: 'merge' | 'replace') {
  const result = await mealHistoryStore.importHistory(pendingImportData.value!, strategy)
  
  if (result.errors.length > 0) {
    toast.error(
      $t('toasts.history.importPartialError', {
        imported: result.imported,
        failed: result.errors.length
      }),
      {
        duration: 7000,
        action: {
          label: $t('common.details'),
          onClick: () => showErrorDetails(result.errors)
        }
      }
    )
  } else {
    toast.success(
      $t('toasts.history.importSuccess', {
        imported: result.imported,
        skipped: result.skipped
      })
    )
  }
}

// Edit loaded
async function handleSaveAndLoad() {
  const mealStore = useMealStore()
  const success = await mealStore.saveAndLoad(pendingHistoryId.value!)
  
  if (success) {
    toast.success($t('toasts.history.loadedForEditing'))
    router.push('/calculator')
  }
}
```

**Calculator View**: Save/update confirmations

```typescript
const toast = useToast()

async function handleSave() {
  const result = await mealStore.saveMeal({ name, notes, tags })
  
  if (result.success) {
    if (mealStore.editingHistoryId) {
      toast.success($t('toasts.calculator.mealUpdated'))
    } else {
      toast.success($t('toasts.calculator.mealSaved'), {
        action: {
          label: $t('common.viewHistory'),
          onClick: () => router.push('/history')
        }
      })
    }
  }
}
```

### 3.3 Breadcrumb Navigation

**New Component**: `src/components/navigation/Breadcrumbs.vue`

```vue
<template>
  <nav aria-label="Breadcrumb" class="mb-4">
    <ol class="flex items-center gap-2 text-sm">
      <li v-for="(crumb, index) in crumbs" :key="crumb.to">
        <div class="flex items-center gap-2">
          <!-- Separator -->
          <ChevronRightIcon
            v-if="index > 0"
            class="w-4 h-4 text-gray-400 dark:text-gray-600"
          />
          
          <!-- Link or current page -->
          <router-link
            v-if="index < crumbs.length - 1"
            :to="crumb.to"
            class="text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white transition-colors"
          >
            {{ crumb.label }}
          </router-link>
          <span
            v-else
            class="font-medium text-gray-900 dark:text-white"
            aria-current="page"
          >
            {{ crumb.label }}
          </span>
        </div>
      </li>
    </ol>
  </nav>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import { useRoute } from 'vue-router'
import { useMealStore } from '@/stores/meal'
import { ChevronRightIcon } from 'lucide-vue-next'

interface Breadcrumb {
  label: string
  to: string
}

const route = useRoute()
const mealStore = useMealStore()

const crumbs = computed<Breadcrumb[]>(() => {
  const base: Breadcrumb[] = []
  
  // Always include home if not on home
  if (route.path !== '/') {
    base.push({ label: 'Home', to: '/' })
  }
  
  // Add current page
  if (route.path === '/calculator') {
    if (mealStore.editingHistoryId) {
      base.push({ label: 'History', to: '/history' })
      base.push({ label: 'Edit Meal', to: '/calculator' })
    } else {
      base.push({ label: 'Calculator', to: '/calculator' })
    }
  } else if (route.path === '/history') {
    base.push({ label: 'History', to: '/history' })
  }
  // Add other routes as needed
  
  return base
})
</script>
```

**Usage in Calculator View**:

```vue
<template>
  <div class="max-w-7xl mx-auto">
    <Breadcrumbs />
    
    <!-- Edit mode banner -->
    <div v-if="isEditingHistory" class="mb-4 p-3 rounded-lg bg-info-50 dark:bg-info-900/20 border border-info-200 dark:border-info-800">
      <div class="flex items-center justify-between">
        <div class="flex items-center gap-2">
          <PencilIcon class="w-5 h-5 text-info-600 dark:text-info-400" />
          <p class="text-sm font-medium text-info-900 dark:text-info-100">
            {{ $t('views.calculator.editingHistory') }}
          </p>
        </div>
        <router-link
          to="/history"
          class="text-sm font-medium text-info-700 dark:text-info-300 hover:underline"
        >
          {{ $t('common.backToHistory') }}
        </router-link>
      </div>
    </div>
    
    <!-- Rest of calculator -->
  </div>
</template>
```

### 3.4 Duplicate Meal Flow

**History View**: Handle duplicate action

```typescript
async function handleDuplicateMeal(meal: MealHistoryEntry) {
  const mealStore = useMealStore()
  
  // Check for unsaved changes (same as edit)
  const result = await mealStore.loadFromHistory(meal.id)
  
  if (!result.success && result.reason === 'unsaved-changes') {
    pendingHistoryId.value = meal.id
    pendingAction.value = 'duplicate'
    showUnsavedDialog.value = true
  } else if (result.success) {
    // Clear editing mode (so it saves as new)
    mealStore.clearEditingMode()
    
    toast.info($t('toasts.history.duplicated'))
    router.push('/calculator')
  }
}

// In dialog handlers
async function handleSaveAndLoad() {
  if (!pendingHistoryId.value) return
  
  const mealStore = useMealStore()
  const success = await mealStore.saveAndLoad(pendingHistoryId.value)
  
  if (success && pendingAction.value === 'duplicate') {
    mealStore.clearEditingMode() // Make it a new meal, not edit
  }
  
  // ... rest of handler
}
```

**Meal Store**: Add clearEditingMode action

```typescript
const clearEditingMode = () => {
  editingHistoryId.value = null
  setInitialHash() // Reset dirty tracking
}

return {
  // ... existing
  clearEditingMode
}
```

### 3.5 Loading States

**Import Progress**: Show progress during large imports

```vue
<template>
  <BaseDialog :open="importLoading">
    <template #title>
      {{ $t('dialogs.importProgress.title') }}
    </template>
    
    <div class="space-y-4">
      <div class="flex items-center gap-3">
        <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-primary-600"></div>
        <div>
          <p class="text-sm font-medium text-gray-900 dark:text-white">
            {{ $t('dialogs.importProgress.processing') }}
          </p>
          <p class="text-xs text-gray-600 dark:text-gray-400">
            {{ importProgress.current }} / {{ importProgress.total }}
          </p>
        </div>
      </div>
      
      <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2">
        <div
          class="bg-primary-600 h-2 rounded-full transition-all"
          :style="{ width: `${(importProgress.current / importProgress.total) * 100}%` }"
        ></div>
      </div>
    </div>
  </BaseDialog>
</template>
```

### 3.6 i18n Strings

```json
{
  "toasts": {
    "history": {
      "exportSuccess": "Exported {count} meals successfully",
      "exportError": "Failed to export history",
      "importSuccess": "Imported {imported} meals ({skipped} skipped)",
      "importPartialError": "Imported {imported} meals, {failed} failed",
      "loadedForEditing": "Meal loaded for editing",
      "duplicated": "Meal duplicated. Make changes and save as new."
    },
    "calculator": {
      "mealSaved": "Meal saved to history",
      "mealUpdated": "Meal updated successfully"
    }
  },
  "common": {
    "backToHistory": "Back to history",
    "viewHistory": "View history",
    "details": "Details"
  }
}
```

### 3.7 Accessibility Enhancements

#### Toast Announcements

```vue
<!-- ToastContainer.vue -->
<div
  aria-live="polite"
  aria-atomic="true"
  role="status"
>
  <!-- Toasts render here -->
</div>
```

- **`aria-live="polite"`**: Screen reader announces toasts without interrupting
- **`aria-atomic="true"`**: Announces entire toast content
- **`role="status"`**: Identifies as status message

#### Focus Management

**After Loading History Entry**:

```typescript
async function handleSaveAndLoad() {
  const success = await mealStore.saveAndLoad(pendingHistoryId.value!)
  
  if (success) {
    router.push('/calculator')
    
    // Focus first input after navigation
    await nextTick()
    const firstInput = document.querySelector<HTMLInputElement>('input, textarea, select')
    firstInput?.focus()
  }
}
```

### 3.8 Testing Requirements

**Toast Tests**: `src/composables/__tests__/useToast.spec.ts`

```typescript
describe('useToast', () => {
  it('shows toast and returns id', () => {
    const { show, toasts } = useToast()
    const id = show({ message: 'Test', variant: 'success' })
    
    expect(id).toBeDefined()
    expect(toasts.value).toHaveLength(1)
    expect(toasts.value[0].message).toBe('Test')
  })

  it('auto-dismisses after duration', async () => {
    vi.useFakeTimers()
    const { show, toasts } = useToast()
    
    show({ message: 'Test', variant: 'info', duration: 1000 })
    expect(toasts.value).toHaveLength(1)
    
    vi.advanceTimersByTime(1000)
    expect(toasts.value).toHaveLength(0)
    
    vi.useRealTimers()
  })
})
```

### 3.9 Success Criteria

- [ ] Toast notifications appear for all major actions (save, export, import, edit, duplicate)
- [ ] Toasts auto-dismiss after 5 seconds (configurable)
- [ ] Toasts show appropriate icons and colors by variant
- [ ] Action buttons in toasts work (e.g., "View history")
- [ ] Breadcrumbs show current location
- [ ] "Back to history" link visible when editing
- [ ] Duplicate flow clears editing mode
- [ ] Loading states show during async operations
- [ ] Focus returns to appropriate element after navigation
- [ ] All toasts announced by screen readers
- [ ] Toast dismiss buttons keyboard accessible

---

## Testing Strategy

### Unit Tests

**Coverage Requirements**: Minimum 80% coverage for new code

**Key Test Files**:

1. **`src/stores/__tests__/mealHistory.export.spec.ts`**
   - Export structure validation
   - Subject filtering
   - Metadata correctness

2. **`src/stores/__tests__/mealHistory.import.spec.ts`**
   - Import validation
   - Merge vs replace strategies
   - Error handling
   - Version compatibility

3. **`src/stores/__tests__/meal.dirtyState.spec.ts`**
   - Dirty state detection
   - Hash comparison accuracy
   - loadFromHistory behavior
   - Edit mode tracking

4. **`src/utils/__tests__/fileHandling.spec.ts`**
   - File download triggering
   - JSON parsing
   - Filename generation
   - Error handling for corrupt files

5. **`src/components/history/__tests__/MealHistoryCard.spec.ts`**
   - Expand/collapse functionality
   - Nutrient list rendering
   - Accessibility attributes
   - Animation states

6. **`src/composables/__tests__/useToast.spec.ts`**
   - Toast creation/dismissal
   - Auto-dismiss timing
   - Variant styling
   - Action callbacks

**Mocking Strategy**:

```typescript
// Mock IndexedDB
vi.mock('@/composables/useIndexedDB', () => ({
  useIndexedDB: () => ({
    saveMealHistory: vi.fn(),
    getMealHistory: vi.fn(),
    getMealHistoryBySubject: vi.fn(),
    removeMealHistory: vi.fn()
  })
}))

// Mock router
const mockRouter = {
  push: vi.fn(),
  replace: vi.fn()
}
vi.mock('vue-router', () => ({
  useRouter: () => mockRouter,
  useRoute: () => ({ path: '/history', query: {} })
}))
```

### Integration Tests

**File**: `src/__tests__/history-edit-flow.spec.ts`

**Scenario**: Complete edit workflow from history to calculator and back

```typescript
import { describe, it, expect, beforeEach } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'
import { useMealStore } from '@/stores/meal'
import { useMealHistoryStore } from '@/stores/mealHistory'
import type { MealHistoryEntry } from '@/types/meal-history'

describe('History Edit Flow (Integration)', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
  })

  it('completes full edit workflow', async () => {
    const mealStore = useMealStore()
    const historyStore = useMealHistoryStore()

    // 1. Create and save initial meal
    await mealStore.addNutrient({ id: '1', name: 'Apple', quantity: 100, factor: 0.14 })
    const saveResult = await mealStore.saveMeal({ name: 'Snack' })
    expect(saveResult.success).toBe(true)

    const savedId = saveResult.entryId!
    expect(historyStore.entries.find(e => e.id === savedId)).toBeDefined()

    // 2. Load for editing
    const loadResult = await mealStore.loadFromHistory(savedId)
    expect(loadResult.success).toBe(true)
    expect(mealStore.editingHistoryId).toBe(savedId)

    // 3. Modify
    await mealStore.addNutrient({ id: '2', name: 'Banana', quantity: 120, factor: 0.23 })
    expect(mealStore.hasUnsavedChanges).toBe(true)

    // 4. Save (should update, not create new)
    const updateResult = await mealStore.saveMeal()
    expect(updateResult.success).toBe(true)
    expect(updateResult.entryId).toBe(savedId)

    // 5. Verify update
    const updated = historyStore.entries.find(e => e.id === savedId)
    expect(updated).toBeDefined()
    expect(updated!.nutrients).toHaveLength(2)
    expect(updated!.metadata.version).toBe(2)
  })

  it('handles unsaved changes correctly', async () => {
    const mealStore = useMealStore()

    // Add nutrient
    await mealStore.addNutrient({ id: '1', name: 'Test', quantity: 50, factor: 0.5 })
    expect(mealStore.hasUnsavedChanges).toBe(true)

    // Attempt to load history (should fail)
    const result = await mealStore.loadFromHistory('some-id')
    expect(result.success).toBe(false)
    expect(result.reason).toBe('unsaved-changes')

    // Force load with skip confirmation
    const forceResult = await mealStore.loadFromHistory('some-id', { skipConfirmation: true })
    // (would succeed if ID exists)
  })
})
```

### E2E Tests

**Coverage**: End-to-end user workflows

#### Test 1: Export and Import Flow

**File**: `e2e/history-export-import.spec.ts`

```typescript
import { test, expect } from '@playwright/test'

test.describe('History Export/Import', () => {
  test('exports and re-imports history', async ({ page }) => {
    // 1. Create some history entries
    await page.goto('/calculator')
    // ... add nutrients and save

    // 2. Navigate to history
    await page.goto('/history')
    
    // 3. Export
    const downloadPromise = page.waitForEvent('download')
    await page.click('button:has-text("Export")')
    const download = await downloadPromise
    
    expect(download.suggestedFilename()).toMatch(/gluko-history.*\.json$/)
    
    // Save file
    const path = await download.path()
    expect(path).toBeTruthy()
    
    // 4. Clear history (or use different profile)
    // ... 
    
    // 5. Import
    await page.setInputFiles('input[type="file"]', path!)
    
    // 6. Choose merge strategy
    await page.click('input[value="merge"]')
    await page.click('button:has-text("Import")')
    
    // 7. Verify entries appear
    await expect(page.locator('.meal-history-card')).toHaveCount(1)
  })
})
```

#### Test 2: Edit Meal with Unsaved Changes

```typescript
test.describe('Edit Meal with Safeguards', () => {
  test('shows confirmation when editing with unsaved work', async ({ page }) => {
    // 1. Create history entry
    await page.goto('/calculator')
    await page.fill('input[name="nutrient-search"]', 'apple')
    await page.click('button:has-text("Add")')
    await page.click('button:has-text("Save")')
    
    // 2. Add new work (unsaved)
    await page.fill('input[name="nutrient-search"]', 'banana')
    await page.click('button:has-text("Add")')
    
    // 3. Go to history
    await page.goto('/history')
    
    // 4. Click edit on first entry
    await page.click('.meal-history-card button:has-text("Edit")')
    
    // 5. Expect confirmation dialog
    await expect(page.locator('dialog:has-text("Unsaved Changes")')).toBeVisible()
    
    // 6. Test "Save & Load"
    await page.click('button:has-text("Save & Load")')
    
    // 7. Should be in calculator with loaded meal
    await expect(page).toHaveURL('/calculator')
  })

  test('allows editing without confirmation when no unsaved work', async ({ page }) => {
    // 1. Create and save entry
    // ...
    
    // 2. Go to history (calculator is clean)
    await page.goto('/history')
    
    // 3. Click edit
    await page.click('.meal-history-card button:has-text("Edit")')
    
    // 4. Should navigate directly (no dialog)
    await expect(page).toHaveURL('/calculator')
    await expect(page.locator('text="Editing saved meal"')).toBeVisible()
  })
})
```

#### Test 3: Expandable Cards

```typescript
test.describe('Expandable History Cards', () => {
  test('expands to show nutrient details', async ({ page }) => {
    await page.goto('/history')
    
    const card = page.locator('.meal-history-card').first()
    const expandButton = card.locator('button[aria-expanded]')
    
    // Initially collapsed
    await expect(expandButton).toHaveAttribute('aria-expanded', 'false')
    await expect(card.locator('[id^="nutrient-list-"]')).not.toBeVisible()
    
    // Expand
    await expandButton.click()
    
    // Now expanded
    await expect(expandButton).toHaveAttribute('aria-expanded', 'true')
    await expect(card.locator('[id^="nutrient-list-"]')).toBeVisible()
    
    // Check nutrient items visible
    const nutrients = card.locator('.nutrient-list-item')
    await expect(nutrients.first()).toBeVisible()
  })

  test('keyboard navigation works', async ({ page }) => {
    await page.goto('/history')
    
    // Tab to first expand button
    await page.keyboard.press('Tab')
    // (might need multiple tabs depending on layout)
    
    // Press Enter to expand
    await page.keyboard.press('Enter')
    
    const expanded = page.locator('[aria-expanded="true"]').first()
    await expect(expanded).toBeVisible()
  })
})
```

### Accessibility Testing

**Tools**: 
- Playwright + axe-core for automated testing
- Manual keyboard navigation testing
- Screen reader testing (NVDA, JAWS, VoiceOver)

**Automated Checks**:

```typescript
import { test, expect } from '@playwright/test'
import AxeBuilder from '@axe-core/playwright'

test.describe('Accessibility', () => {
  test('history view has no accessibility violations', async ({ page }) => {
    await page.goto('/history')
    
    const results = await new AxeBuilder({ page }).analyze()
    expect(results.violations).toEqual([])
  })

  test('unsaved changes dialog is accessible', async ({ page }) => {
    // Trigger dialog
    // ...
    
    const results = await new AxeBuilder({ page })
      .include('dialog')
      .analyze()
    
    expect(results.violations).toEqual([])
  })

  test('expandable cards are accessible', async ({ page }) => {
    await page.goto('/history')
    
    const results = await new AxeBuilder({ page })
      .include('.meal-history-card')
      .analyze()
    
    expect(results.violations).toEqual([])
  })
})
```

**Manual Testing Checklist**:

- [ ] All interactive elements reachable by Tab
- [ ] Focus indicators visible on all focusable elements
- [ ] Dialogs trap focus (can't tab out)
- [ ] Escape key closes dialogs
- [ ] Screen reader announces:
  - Toast messages
  - Dialog titles and content
  - Button states (expanded/collapsed)
  - Form validation errors
  - Loading states
- [ ] Color contrast meets WCAG AA (4.5:1 for normal text)
- [ ] No keyboard traps
- [ ] Skip links work (if implemented)

**Screen Reader Testing**:

| Feature          | Expected Announcement                          |
| ---------------- | ---------------------------------------------- |
| Expand button    | "Show details button, collapsed"               |
| After expanding  | "Hide details button, expanded"                |
| Nutrient list    | "List, 3 items"                                |
| Toast success    | "Meal saved to history" (polite)               |
| Edit mode banner | "Editing saved meal"                           |
| Unsaved dialog   | "Unsaved changes. You have unsaved changes..." |

### Performance Testing

**Metrics**:
- Export 1000 entries: < 2 seconds
- Import 1000 entries: < 5 seconds
- Expand/collapse animation: 60fps
- Toast render: < 100ms

**Large Dataset Tests**:

```typescript
test('handles large export', async ({ page }) => {
  // Create 1000 history entries
  // ...
  
  await page.goto('/history')
  
  const startTime = Date.now()
  const downloadPromise = page.waitForEvent('download')
  await page.click('button:has-text("Export")')
  const download = await downloadPromise
  const duration = Date.now() - startTime
  
  expect(duration).toBeLessThan(2000) // 2 second max
})
```

---

## Deployment Checklist

- [ ] All unit tests passing
- [ ] E2E tests covering export/import flow
- [ ] Accessibility audit (keyboard nav, screen reader)
- [ ] File size testing (large history exports)
- [ ] Error handling tested (corrupt files, version mismatches)
- [ ] Mobile testing (file download/upload on iOS/Android)
- [ ] Documentation updated (user guide, AGENTS.md)
- [ ] i18n strings added for EN/FR

---

## References

- **Release Plan**: [v0.6-history-export.md](../releases/v0.6-history-export.md)
- **Architecture**: [ARCHITECTURE.md](../ARCHITECTURE.md)
- **Type Definitions**: `src/types/meal-history.ts`
- **Stores**: `src/stores/mealHistory.ts`, `src/stores/meal.ts`
- **Components**: `src/components/history/MealHistoryCard.vue`, `src/views/MealHistoryView.vue`

---

## Glossary

- **Dirty State**: Calculator has unsaved changes (nutrients modified but not saved to history)
- **History Entry**: Saved meal calculation stored in IndexedDB
- **Active Session**: Current draft calculation in progress
- **Schema Version**: Version identifier for export file format
- **Merge Conflict**: Import file contains entries with same IDs as existing data
