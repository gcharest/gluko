# Implementation: v0.5 Complete App Redesign + Performance Optimization

## Overview

This document provides detailed technical implementation for v0.5, which combines the complete UI/UX redesign (Reka UI + Tailwind CSS migration) with core performance optimizations (Web Workers, Service Worker caching, streaming imports). See the [release planning document](../releases/v0.5-complete-redesign.md) for goals and context.

**Status**: Active implementation guide
**Replaces**: v0.4 implementation (merged into this document)

## Architecture Overview

### High-Level Design Principles

1. **Separation of Concerns**:
   - **Data Layer** (unchanged from v0.3): Composables, stores, IndexedDB
   - **Business Logic** (unchanged): Calculation, search, history management
   - **Presentation Layer** (complete rewrite): Components, layouts, styling

2. **Performance First**:
   - Non-blocking UI thread (Web Workers for heavy lifting)
   - Streaming data processing (no large in-memory buffers)
   - Chunked transactions (responsive during imports)
   - Aggressive caching (Service Worker for offline)

3. **Accessibility by Default**:
   - Reka UI provides WCAG 2.1 AAA foundation
   - Semantic HTML with proper ARIA attributes
   - Keyboard navigation built into all interactions
   - Focus management in modals and overlays

4. **Mobile-First Responsive**:
   - Bottom navigation on mobile (< 768px)
   - Side rail navigation on desktop (≥ 768px)
   - Touch-friendly targets (44×44px minimum)
   - Swipe gestures on mobile for common actions

## Technology Stack

### UI Framework
```json
{
  "reka-ui": "^2.0.0",           // Headless accessible components (formerly Radix Vue)
  "tailwindcss": "^3.4.0",       // Utility-first CSS framework
  "lucide-vue-next": "^0.447.0", // Icon set with Vue components
  "@vueuse/core": "^11.0.0"      // Vue composition utilities
}
```

### Performance Infrastructure
```json
{
  "workbox-window": "^7.0.0",    // Service Worker helpers
  "comlink": "^4.4.1"            // Web Worker RPC abstraction (optional)
}
```

### Development Tools
```json
{
  "@tailwindcss/forms": "^0.5.7",     // Form styling plugin
  "@tailwindcss/typography": "^0.5.10", // Typography plugin
  "postcss": "^8.4.31",               // CSS processing
  "autoprefixer": "^10.4.16"          // Browser prefixing
}
```

## Phase 1: Foundation Setup

### 1.1 Install Dependencies

```bash
# UI dependencies
npm install reka-ui
npm install -D tailwindcss postcss autoprefixer
npm install lucide-vue-next
npm install @vueuse/core

# Tailwind plugins
npm install -D @tailwindcss/forms @tailwindcss/typography

# Service Worker helpers
npm install workbox-window

# Optional: Web Worker RPC
npm install comlink
```

### 1.2 Tailwind Configuration

Create `tailwind.config.js`:

```javascript
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{vue,js,ts,jsx,tsx}",
  ],
  darkMode: 'class', // Enable class-based dark mode
  theme: {
    extend: {
      colors: {
        // Brand colors
        primary: {
          50: '#f0f9ff',
          100: '#e0f2fe',
          200: '#bae6fd',
          300: '#7dd3fc',
          400: '#38bdf8',
          500: '#0ea5e9', // DEFAULT
          600: '#0284c7',
          700: '#0369a1',
          800: '#075985',
          900: '#0c4a6e',
          950: '#082f49',
        },
        // Semantic colors
        success: {
          DEFAULT: '#10b981',
          light: '#6ee7b7',
          dark: '#047857',
        },
        warning: {
          DEFAULT: '#f59e0b',
          light: '#fbbf24',
          dark: '#d97706',
        },
        danger: {
          DEFAULT: '#ef4444',
          light: '#f87171',
          dark: '#dc2626',
        },
      },
      fontFamily: {
        sans: ['Inter', 'system-ui', 'sans-serif'],
        mono: ['JetBrains Mono', 'monospace'],
      },
      spacing: {
        // iOS safe area insets
        'safe': 'env(safe-area-inset-bottom)',
      },
      animation: {
        'fade-in': 'fadeIn 150ms ease-out',
        'slide-up': 'slideUp 200ms ease-out',
      },
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0' },
          '100%': { opacity: '1' },
        },
        slideUp: {
          '0%': { transform: 'translateY(10px)', opacity: '0' },
          '100%': { transform: 'translateY(0)', opacity: '1' },
        },
      },
    },
  },
  plugins: [
    require('@tailwindcss/forms'),
    require('@tailwindcss/typography'),
  ],
}
```

### 1.3 PostCSS Configuration

Create `postcss.config.js`:

```javascript
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
```

### 1.4 Import Tailwind in CSS

Update `src/assets/main.css`:

```css
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Custom base styles */
@layer base {
  /* Respect reduced motion */
  @media (prefers-reduced-motion: reduce) {
    *,
    *::before,
    *::after {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
    }
  }

  /* Focus styles */
  :focus-visible {
    @apply outline-none ring-2 ring-primary-500 ring-offset-2;
  }

  /* Dark mode text colors */
  html.dark {
    color-scheme: dark;
  }
}

/* Custom component layer */
@layer components {
  /* Add reusable component classes here */
}
```

### 1.5 Remove Bootstrap

Update `src/main.ts`:

```typescript
// REMOVE these lines:
// import 'bootstrap/dist/css/bootstrap.min.css'
// import 'bootstrap-icons/font/bootstrap-icons.css'

// KEEP these:
import './assets/main.css' // Now imports Tailwind
import { createApp } from 'vue'
import App from './App.vue'
// ... rest of setup
```

Remove Bootstrap from `package.json`:

```bash
npm uninstall bootstrap bootstrap-icons
```

### 1.6 Dark Mode Setup

Create `src/composables/useDarkMode.ts`:

```typescript
import { useColorMode } from '@vueuse/core'

export function useDarkMode() {
  const mode = useColorMode({
    modes: {
      light: 'light',
      dark: 'dark',
      auto: 'auto'
    },
    storageKey: 'gluko-theme',
  })

  return {
    mode,
    isDark: computed(() => mode.value === 'dark'),
    isLight: computed(() => mode.value === 'light'),
    isAuto: computed(() => mode.value === 'auto'),
    setLight: () => { mode.value = 'light' },
    setDark: () => { mode.value = 'dark' },
    setAuto: () => { mode.value = 'auto' },
  }
}
```

Update `src/App.vue`:

```vue
<script setup lang="ts">
import { useDarkMode } from '@/composables/useDarkMode'

const { isDark } = useDarkMode()
</script>

<template>
  <div id="app" :class="{ 'dark': isDark }">
    <!-- App content -->
  </div>
</template>
```

## Phase 2: Base Component Library

### 2.1 Button Component

Create `src/components/base/BaseButton.vue`:

```vue
<template>
  <button
    :type="type"
    :class="buttonClasses"
    :disabled="disabled || loading"
    :aria-disabled="disabled || loading"
    :aria-busy="loading"
    v-bind="$attrs"
  >
    <span v-if="loading" class="absolute inset-0 flex items-center justify-center">
      <LoaderIcon class="w-5 h-5 animate-spin" />
    </span>
    <span :class="{ 'opacity-0': loading }">
      <slot />
    </span>
  </button>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import { LoaderIcon } from 'lucide-vue-next'

interface Props {
  variant?: 'primary' | 'secondary' | 'danger' | 'ghost'
  size?: 'sm' | 'md' | 'lg'
  type?: 'button' | 'submit' | 'reset'
  disabled?: boolean
  loading?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  variant: 'primary',
  size: 'md',
  type: 'button',
  disabled: false,
  loading: false,
})

const buttonClasses = computed(() => {
  const base = [
    'relative inline-flex items-center justify-center',
    'font-medium rounded-lg',
    'transition-all duration-150',
    'focus:outline-none focus:ring-2 focus:ring-offset-2',
    'disabled:opacity-50 disabled:cursor-not-allowed',
    'min-h-[44px]', // Touch target
  ]

  const variants = {
    primary: [
      'bg-primary-600 text-white',
      'hover:bg-primary-700 active:bg-primary-800',
      'focus:ring-primary-500',
    ],
    secondary: [
      'bg-gray-200 text-gray-900 dark:bg-gray-700 dark:text-gray-100',
      'hover:bg-gray-300 dark:hover:bg-gray-600',
      'focus:ring-gray-500',
    ],
    danger: [
      'bg-danger-600 text-white',
      'hover:bg-danger-700 active:bg-danger-800',
      'focus:ring-danger-500',
    ],
    ghost: [
      'bg-transparent text-gray-700 dark:text-gray-300',
      'hover:bg-gray-100 dark:hover:bg-gray-800',
      'focus:ring-gray-500',
    ],
  }

  const sizes = {
    sm: 'px-3 py-2 text-sm',
    md: 'px-4 py-2 text-base',
    lg: 'px-6 py-3 text-lg',
  }

  return [
    ...base,
    ...variants[props.variant],
    sizes[props.size],
  ]
})
</script>
```

### 2.2 Input Component

Create `src/components/base/BaseInput.vue`:

```vue
<template>
  <div class="base-input">
    <label
      v-if="label"
      :for="inputId"
      class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2"
    >
      {{ label }}
      <span v-if="required" class="text-danger-500">*</span>
    </label>

    <div class="relative">
      <input
        :id="inputId"
        :type="type"
        :value="modelValue"
        :placeholder="placeholder"
        :disabled="disabled"
        :required="required"
        :aria-label="ariaLabel || label"
        :aria-invalid="!!error"
        :aria-describedby="error ? `${inputId}-error` : undefined"
        :class="inputClasses"
        @input="handleInput"
        @blur="handleBlur"
        v-bind="$attrs"
      />

      <div v-if="$slots.suffix" class="absolute inset-y-0 right-0 flex items-center pr-3">
        <slot name="suffix" />
      </div>
    </div>

    <p
      v-if="error"
      :id="`${inputId}-error`"
      class="mt-1 text-sm text-danger-600 dark:text-danger-400"
    >
      {{ error }}
    </p>

    <p
      v-else-if="hint"
      class="mt-1 text-sm text-gray-500 dark:text-gray-400"
    >
      {{ hint }}
    </p>
  </div>
</template>

<script setup lang="ts">
import { computed, ref } from 'vue'

interface Props {
  modelValue: string | number
  type?: 'text' | 'email' | 'password' | 'search' | 'number' | 'tel'
  label?: string
  placeholder?: string
  hint?: string
  error?: string
  disabled?: boolean
  required?: boolean
  ariaLabel?: string
}

const props = withDefaults(defineProps<Props>(), {
  type: 'text',
  disabled: false,
  required: false,
})

const emit = defineEmits<{
  'update:modelValue': [value: string | number]
  'blur': []
}>()

const inputId = ref(`input-${Math.random().toString(36).substring(2, 9)}`)

const inputClasses = computed(() => [
  'block w-full rounded-lg',
  'px-4 py-2',
  'text-base text-gray-900 dark:text-gray-100',
  'bg-white dark:bg-gray-800',
  'border',
  props.error
    ? 'border-danger-500 focus:border-danger-500 focus:ring-danger-500'
    : 'border-gray-300 dark:border-gray-600 focus:border-primary-500 focus:ring-primary-500',
  'placeholder-gray-400 dark:placeholder-gray-500',
  'focus:outline-none focus:ring-2 focus:ring-offset-0',
  'disabled:bg-gray-100 dark:disabled:bg-gray-900 disabled:cursor-not-allowed',
  'transition-colors duration-150',
])

function handleInput(event: Event) {
  const target = event.target as HTMLInputElement
  const value = props.type === 'number' ? Number(target.value) : target.value
  emit('update:modelValue', value)
}

function handleBlur() {
  emit('blur')
}
</script>
```

### 2.3 Card Component

Create `src/components/base/BaseCard.vue`:

```vue
<template>
  <div :class="cardClasses">
    <div v-if="$slots.header || title" class="card-header">
      <slot name="header">
        <h3 v-if="title" class="text-lg font-semibold text-gray-900 dark:text-gray-100">
          {{ title }}
        </h3>
      </slot>
    </div>

    <div class="card-body">
      <slot />
    </div>

    <div v-if="$slots.footer" class="card-footer">
      <slot name="footer" />
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'

interface Props {
  title?: string
  variant?: 'default' | 'elevated' | 'outlined'
  padding?: 'none' | 'sm' | 'md' | 'lg'
}

const props = withDefaults(defineProps<Props>(), {
  variant: 'default',
  padding: 'md',
})

const cardClasses = computed(() => {
  const base = [
    'bg-white dark:bg-gray-800',
    'rounded-lg',
    'overflow-hidden',
  ]

  const variants = {
    default: 'shadow-sm',
    elevated: 'shadow-md',
    outlined: 'border border-gray-200 dark:border-gray-700',
  }

  return [
    ...base,
    variants[props.variant],
  ]
})
</script>

<style scoped>
.card-header {
  @apply px-4 py-3 border-b border-gray-200 dark:border-gray-700;
}

.card-body {
  @apply px-4 py-3;
}

.card-footer {
  @apply px-4 py-3 border-t border-gray-200 dark:border-gray-700;
}
</style>
```

### 2.4 Modal Component (Using Reka UI)

Create `src/components/base/BaseModal.vue`:

```vue
<template>
  <DialogRoot v-model:open="isOpen">
    <DialogPortal>
      <DialogOverlay
        class="fixed inset-0 bg-black/50 backdrop-blur-sm z-40"
        @click="handleClose"
      />
      <DialogContent
        :class="modalClasses"
        @escape-key-down="handleClose"
      >
        <DialogTitle
          v-if="title"
          class="text-xl font-semibold text-gray-900 dark:text-gray-100 mb-4"
        >
          {{ title }}
        </DialogTitle>

        <DialogDescription v-if="description" class="sr-only">
          {{ description }}
        </DialogDescription>

        <div class="modal-body">
          <slot />
        </div>

        <DialogClose
          v-if="showClose"
          class="absolute top-4 right-4 text-gray-400 hover:text-gray-600 dark:hover:text-gray-200"
          aria-label="Close"
        >
          <XIcon class="w-5 h-5" />
        </DialogClose>
      </DialogContent>
    </DialogPortal>
  </DialogRoot>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import {
  DialogRoot,
  DialogPortal,
  DialogOverlay,
  DialogContent,
  DialogTitle,
  DialogDescription,
  DialogClose,
} from 'reka-ui'
import { XIcon } from 'lucide-vue-next'

interface Props {
  open: boolean
  title?: string
  description?: string
  size?: 'sm' | 'md' | 'lg' | 'xl'
  showClose?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  size: 'md',
  showClose: true,
})

const emit = defineEmits<{
  'update:open': [value: boolean]
}>()

const isOpen = computed({
  get: () => props.open,
  set: (value) => emit('update:open', value),
})

const modalClasses = computed(() => {
  const base = [
    'fixed left-1/2 top-1/2 z-50',
    'transform -translate-x-1/2 -translate-y-1/2',
    'bg-white dark:bg-gray-800',
    'rounded-lg shadow-xl',
    'p-6',
    'max-h-[90vh] overflow-y-auto',
  ]

  const sizes = {
    sm: 'w-full max-w-sm',
    md: 'w-full max-w-md',
    lg: 'w-full max-w-lg',
    xl: 'w-full max-w-xl',
  }

  return [
    ...base,
    sizes[props.size],
  ]
})

function handleClose() {
  emit('update:open', false)
}
</script>
```

## Phase 3: Navigation Architecture

### 3.1 Bottom Navigation Component

Create `src/components/navigation/BottomNav.vue`:

```vue
<template>
  <nav
    class="bottom-nav"
    role="navigation"
    :aria-label="t('navigation.main')"
  >
    <NavItem
      v-for="item in navItems"
      :key="item.to"
      :to="item.to"
      :icon="item.icon"
      :label="item.label"
      :badge="item.badge"
    />
  </nav>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import { useI18n } from 'vue-i18n'
import { useMealStore } from '@/stores/meal'
import { useMealHistoryStore } from '@/stores/mealHistory'
import NavItem from './NavItem.vue'

const { t } = useI18n()
const mealStore = useMealStore()
const historyStore = useMealHistoryStore()

const navItems = computed(() => [
  {
    to: '/search',
    icon: 'Search',
    label: t('navigation.search'),
    badge: null,
  },
  {
    to: '/calculator',
    icon: 'Calculator',
    label: t('navigation.calculator'),
    badge: mealStore.itemCount > 0 ? mealStore.itemCount : null,
  },
  {
    to: '/history',
    icon: 'History',
    label: t('navigation.history'),
    badge: null,
  },
  {
    to: '/profile',
    icon: 'User',
    label: t('navigation.profile'),
    badge: null,
  },
])
</script>

<style scoped>
.bottom-nav {
  @apply fixed bottom-0 left-0 right-0 z-50;
  @apply bg-white dark:bg-gray-900;
  @apply border-t border-gray-200 dark:border-gray-800;
  @apply flex items-center justify-around;
  @apply h-16;
  @apply shadow-lg;

  /* iOS safe area */
  padding-bottom: env(safe-area-inset-bottom);
}

/* Desktop: side rail */
@media (min-width: 768px) {
  .bottom-nav {
    @apply fixed left-0 top-0 bottom-0 right-auto;
    @apply w-20 h-full;
    @apply flex-col justify-start pt-4 gap-2;
    @apply border-t-0 border-r;
    padding-bottom: 0;
  }
}
</style>
```

### 3.2 Nav Item Component

Create `src/components/navigation/NavItem.vue`:

```vue
<template>
  <RouterLink
    :to="to"
    :class="navItemClasses"
    :aria-current="isActive ? 'page' : undefined"
  >
    <div class="relative">
      <component
        :is="iconComponent"
        :class="iconClasses"
      />
      <span
        v-if="badge"
        class="absolute -top-1 -right-1 flex items-center justify-center w-5 h-5 text-xs font-bold text-white bg-danger-500 rounded-full"
      >
        {{ badge }}
      </span>
    </div>
    <span :class="labelClasses">{{ label }}</span>
  </RouterLink>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import { useRoute } from 'vue-router'
import { Search, Calculator, History, User } from 'lucide-vue-next'

interface Props {
  to: string
  icon: 'Search' | 'Calculator' | 'History' | 'User'
  label: string
  badge?: number | null
}

const props = defineProps<Props>()

const route = useRoute()

const iconComponents = {
  Search,
  Calculator,
  History,
  User,
}

const iconComponent = computed(() => iconComponents[props.icon])

const isActive = computed(() => route.path.startsWith(props.to))

const navItemClasses = computed(() => [
  'flex flex-col items-center justify-center',
  'min-w-[60px] h-full',
  'text-sm font-medium',
  'transition-colors duration-150',
  'focus:outline-none focus-visible:ring-2 focus-visible:ring-primary-500',
  isActive.value
    ? 'text-primary-600 dark:text-primary-400'
    : 'text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100',
])

const iconClasses = computed(() => [
  'w-6 h-6 mb-1',
  isActive.value && 'stroke-[2.5]',
])

const labelClasses = computed(() => [
  'text-xs',
  'hidden md:block', // Hide on mobile, show on desktop
])
</script>
```

## Phase 4: Web Worker Implementation

### 4.1 Web Worker File

Create `public/workers/shard-worker.js`:

```javascript
/**
 * Web Worker for NDJSON shard parsing and IndexedDB import
 * Runs off main thread to keep UI responsive
 */

const CHUNK_SIZE = 1000 // Records per transaction (tune for device)

// Open IndexedDB connection
let db = null

async function openDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('gluko-db', 3)

    request.onsuccess = () => {
      db = request.result
      resolve(db)
    }

    request.onerror = () => reject(request.error)
  })
}

// Parse NDJSON content
function parseNDJSON(content) {
  const lines = content.split('\n').filter(line => line.trim().length > 0)
  const records = []

  for (let i = 0; i < lines.length; i++) {
    try {
      const record = JSON.parse(lines[i])
      if (record.id && record.FoodDescription) {
        records.push(record)
      }
    } catch (error) {
      console.error(`Failed to parse line ${i + 1}:`, error)
      throw new Error(`Invalid NDJSON at line ${i + 1}`)
    }
  }

  return records
}

// Import records in chunks
async function importRecordsChunked(records, onProgress) {
  if (!db) {
    await openDB()
  }

  const totalChunks = Math.ceil(records.length / CHUNK_SIZE)

  for (let i = 0; i < totalChunks; i++) {
    const start = i * CHUNK_SIZE
    const end = Math.min(start + CHUNK_SIZE, records.length)
    const chunk = records.slice(start, end)

    // Write chunk in single transaction
    await new Promise((resolve, reject) => {
      const transaction = db.transaction(['nutrientsFile'], 'readwrite')
      const store = transaction.objectStore('nutrientsFile')

      for (const record of chunk) {
        store.put(record)
      }

      transaction.oncomplete = () => resolve()
      transaction.onerror = () => reject(transaction.error)
      transaction.onabort = () => reject(new Error('Transaction aborted'))
    })

    // Report progress
    const progress = Math.round(((i + 1) / totalChunks) * 100)
    if (onProgress) {
      onProgress(progress, i + 1, totalChunks)
    }
  }
}

// Message handler
self.addEventListener('message', async (event) => {
  const { type, payload } = event.data

  try {
    switch (type) {
      case 'PARSE_SHARD': {
        const { content } = payload
        const records = parseNDJSON(content)

        self.postMessage({
          type: 'PARSE_SUCCESS',
          payload: { recordCount: records.length },
        })

        // Start importing
        await importRecordsChunked(records, (progress, chunk, total) => {
          self.postMessage({
            type: 'IMPORT_PROGRESS',
            payload: { progress, chunk, total },
          })
        })

        self.postMessage({
          type: 'IMPORT_COMPLETE',
          payload: { recordCount: records.length },
        })

        break
      }

      case 'INIT_DB': {
        await openDB()
        self.postMessage({
          type: 'DB_READY',
        })
        break
      }

      default:
        console.warn(`Unknown message type: ${type}`)
    }
  } catch (error) {
    self.postMessage({
      type: 'ERROR',
      payload: {
        message: error.message,
        stack: error.stack,
      },
    })
  }
})

// Signal ready
self.postMessage({ type: 'WORKER_READY' })
```

### 4.2 Web Worker Composable

Create `src/composables/useShardWorker.ts`:

```typescript
import { ref, onUnmounted } from 'vue'

interface WorkerMessage {
  type: string
  payload?: Record<string, unknown>
}

interface WorkerProgress {
  progress: number
  chunk: number
  total: number
}

export function useShardWorker() {
  const worker = ref<Worker | null>(null)
  const isReady = ref(false)
  const isProcessing = ref(false)
  const progress = ref<WorkerProgress>({
    progress: 0,
    chunk: 0,
    total: 0,
  })

  function initWorker() {
    if (typeof Worker === 'undefined') {
      console.warn('Web Workers not supported')
      return false
    }

    try {
      worker.value = new Worker('/gluko/workers/shard-worker.js')

      worker.value.addEventListener('message', handleMessage)
      worker.value.addEventListener('error', handleError)

      return true
    } catch (error) {
      console.error('Failed to initialize worker:', error)
      return false
    }
  }

  function handleMessage(event: MessageEvent<WorkerMessage>) {
    const { type, payload } = event.data

    switch (type) {
      case 'WORKER_READY':
        isReady.value = true
        break

      case 'DB_READY':
        console.log('Worker: IndexedDB ready')
        break

      case 'PARSE_SUCCESS':
        console.log(`Worker: Parsed ${payload?.recordCount} records`)
        break

      case 'IMPORT_PROGRESS':
        progress.value = payload as WorkerProgress
        break

      case 'IMPORT_COMPLETE':
        console.log(`Worker: Imported ${payload?.recordCount} records`)
        isProcessing.value = false
        progress.value = { progress: 100, chunk: 0, total: 0 }
        break

      case 'ERROR':
        console.error('Worker error:', payload?.message)
        isProcessing.value = false
        break

      default:
        console.warn(`Unknown worker message: ${type}`)
    }
  }

  function handleError(error: ErrorEvent) {
    console.error('Worker error:', error)
    isProcessing.value = false
  }

  async function processShard(content: string): Promise<void> {
    if (!worker.value || !isReady.value) {
      throw new Error('Worker not initialized')
    }

    isProcessing.value = true
    progress.value = { progress: 0, chunk: 0, total: 0 }

    return new Promise((resolve, reject) => {
      const messageHandler = (event: MessageEvent<WorkerMessage>) => {
        const { type, payload } = event.data

        if (type === 'IMPORT_COMPLETE') {
          worker.value?.removeEventListener('message', messageHandler)
          resolve()
        } else if (type === 'ERROR') {
          worker.value?.removeEventListener('message', messageHandler)
          reject(new Error(payload?.message as string))
        }
      }

      worker.value?.addEventListener('message', messageHandler)
      worker.value?.postMessage({
        type: 'PARSE_SHARD',
        payload: { content },
      })
    })
  }

  function terminate() {
    if (worker.value) {
      worker.value.terminate()
      worker.value = null
      isReady.value = false
    }
  }

  // Cleanup on unmount
  onUnmounted(() => {
    terminate()
  })

  return {
    worker,
    isReady,
    isProcessing,
    progress,
    initWorker,
    processShard,
    terminate,
  }
}
```

### 4.3 Enhanced Shard Loader with Web Worker

Update `src/composables/useShardLoader.ts`:

```typescript
// Add to existing useShardLoader composable

import { useShardWorker } from './useShardWorker'

export function useShardLoader() {
  const db = useIndexedDB()
  const { initWorker, isReady: workerReady, processShard, progress: workerProgress } = useShardWorker()

  // Try to initialize worker on creation
  const useWorker = initWorker()

  const progress = ref({
    currentShard: 0,
    totalShards: 0,
    currentShardProgress: 0,
    status: 'idle' as const,
  })

  // ... existing functions (fetchManifest, getChangedShards, downloadShard, etc.)

  async function importShard(
    shard: ShardDescriptor,
    records: NutrientRecord[]
  ): Promise<void> {
    try {
      if (useWorker && workerReady.value) {
        // Use Web Worker for non-blocking import
        const content = records.map(r => JSON.stringify(r)).join('\n')
        await processShard(content)
      } else {
        // Fallback to main thread
        await db.importNutrientRecords(records)
      }

      // Save shard metadata
      await db.saveShardMetadata({
        id: shard.id,
        filename: shard.filename,
        checksum: shard.checksum,
        loadedAt: Date.now(),
        recordCount: records.length,
        status: 'loaded',
      })
    } catch (error) {
      // Save error state
      await db.saveShardMetadata({
        id: shard.id,
        filename: shard.filename,
        checksum: shard.checksum,
        loadedAt: Date.now(),
        recordCount: 0,
        status: 'error',
        errorMessage: error instanceof Error ? error.message : 'Unknown error',
      })

      throw error
    }
  }

  // ... rest of composable
}
```

## Phase 5: Service Worker Enhancement

### 5.1 Enhanced Service Worker

Update `public/service-worker.js`:

```javascript
const CACHE_VERSION = 'v0.5.0'
const CACHE_NAME = `gluko-${CACHE_VERSION}`

// Assets to cache immediately
const PRECACHE_URLS = [
  '/gluko/',
  '/gluko/index.html',
  '/gluko/manifest.webmanifest',
  // Add other critical assets
]

// Install event
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      return cache.addAll(PRECACHE_URLS)
    }).then(() => {
      // Activate immediately
      return self.skipWaiting()
    })
  )
})

// Activate event - clean old caches
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter((name) => name.startsWith('gluko-') && name !== CACHE_NAME)
          .map((name) => caches.delete(name))
      )
    }).then(() => {
      return self.clients.claim()
    })
  )
})

// Fetch event - cache strategy
self.addEventListener('fetch', (event) => {
  const { request } = event
  const url = new URL(request.url)

  // Handle manifest.json - always fetch, then cache
  if (url.pathname.endsWith('/data/manifest.json')) {
    event.respondWith(
      fetch(request)
        .then((response) => {
          const clone = response.clone()
          caches.open(CACHE_NAME).then((cache) => {
            cache.put(request, clone)
          })
          return response
        })
        .catch(() => caches.match(request))
    )
    return
  }

  // Handle shard files (.ndjson) - cache-first with revalidation
  if (url.pathname.endsWith('.ndjson')) {
    event.respondWith(
      caches.match(request).then((cachedResponse) => {
        if (cachedResponse) {
          // Return cached, but fetch and update in background
          fetch(request).then((response) => {
            caches.open(CACHE_NAME).then((cache) => {
              cache.put(request, response)
            })
          }).catch(() => {})

          return cachedResponse
        }

        // Not in cache, fetch and cache
        return fetch(request).then((response) => {
          const clone = response.clone()
          caches.open(CACHE_NAME).then((cache) => {
            cache.put(request, clone)
          })
          return response
        })
      })
    )
    return
  }

  // Default strategy: network-first with cache fallback
  event.respondWith(
    fetch(request)
      .then((response) => {
        // Cache successful responses
        if (response.ok) {
          const clone = response.clone()
          caches.open(CACHE_NAME).then((cache) => {
            cache.put(request, clone)
          })
        }
        return response
      })
      .catch(() => caches.match(request))
  )
})
```

## Phase 6: View Migrations

### 6.1 Search View Example

Create `src/views/SearchView.vue` (new design):

```vue
<template>
  <div class="search-view">
    <div class="search-container">
      <!-- Search input -->
      <div class="relative">
        <SearchIcon class="absolute left-4 top-1/2 transform -translate-y-1/2 w-5 h-5 text-gray-400 pointer-events-none" />
        <input
          ref="searchInput"
          v-model="query"
          type="search"
          class="search-input"
          :placeholder="t('search.placeholder')"
          @input="handleSearch"
          @focus="showSuggestions = true"
        />
        <button
          v-if="query"
          class="absolute right-4 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600"
          @click="clearSearch"
          :aria-label="t('search.clear')"
        >
          <XIcon class="w-5 h-5" />
        </button>
      </div>

      <!-- Filters -->
      <div class="flex gap-2 mt-4">
        <button
          class="chip"
          :class="{ 'chip-active': showFavoritesOnly }"
          @click="toggleFavorites"
        >
          <HeartIcon class="w-4 h-4" />
          {{ t('search.favorites') }}
        </button>
      </div>

      <!-- Recent searches -->
      <div v-if="!query && recentSearches.length" class="mt-6">
        <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          {{ t('search.recent') }}
        </h3>
        <div class="space-y-1">
          <button
            v-for="recent in recentSearches"
            :key="recent"
            class="recent-search-item"
            @click="query = recent"
          >
            <ClockIcon class="w-4 h-4 text-gray-400" />
            <span>{{ recent }}</span>
          </button>
        </div>
      </div>

      <!-- Search results -->
      <div v-if="results.length" class="mt-6 space-y-2">
        <h3 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          {{ t('search.results', { count: results.length }) }}
        </h3>
        <FoodResultCard
          v-for="food in results"
          :key="food.id"
          :food="food"
          @add="handleAddFood"
          @toggle-favorite="handleToggleFavorite"
        />
      </div>

      <!-- Empty state -->
      <div v-else-if="query && !isSearching" class="empty-state">
        <SearchIcon class="w-12 h-12 text-gray-300" />
        <p class="text-gray-500 mt-2">{{ t('search.noResults') }}</p>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import { useI18n } from 'vue-i18n'
import { SearchIcon, XIcon, ClockIcon, HeartIcon } from 'lucide-vue-next'
import { useNutrientSearch } from '@/composables/useNutrientSearch'
import FoodResultCard from '@/components/search/FoodResultCard.vue'

const { t } = useI18n()
const { search, results, isSearching } = useNutrientSearch()

const query = ref('')
const showSuggestions = ref(false)
const showFavoritesOnly = ref(false)
const recentSearches = ref<string[]>([])
const searchInput = ref<HTMLInputElement>()

// Auto-focus search on mount
onMounted(() => {
  searchInput.value?.focus()
})

// Debounced search
const handleSearch = useDebounceFn(() => {
  if (query.value.length >= 2) {
    search(query.value, { favoritesOnly: showFavoritesOnly.value })

    // Add to recent searches
    if (!recentSearches.value.includes(query.value)) {
      recentSearches.value.unshift(query.value)
      recentSearches.value = recentSearches.value.slice(0, 5)
    }
  }
}, 300)

function clearSearch() {
  query.value = ''
  searchInput.value?.focus()
}

function toggleFavorites() {
  showFavoritesOnly.value = !showFavoritesOnly.value
  if (query.value) {
    handleSearch()
  }
}

function handleAddFood(food: NutrientRecord) {
  // Add to calculator
  // Show toast notification
}

function handleToggleFavorite(food: NutrientRecord) {
  // Toggle favorite status
}
</script>

<style scoped>
.search-view {
  @apply min-h-screen bg-gray-50 dark:bg-gray-900;
  @apply pb-20 md:pb-0 md:pl-20; /* Account for bottom nav / side rail */
}

.search-container {
  @apply max-w-2xl mx-auto px-4 py-6;
}

.search-input {
  @apply w-full pl-12 pr-12 py-3;
  @apply text-base text-gray-900 dark:text-gray-100;
  @apply bg-white dark:bg-gray-800;
  @apply border border-gray-300 dark:border-gray-600;
  @apply rounded-xl;
  @apply placeholder-gray-400;
  @apply focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent;
  @apply transition-all duration-150;
}

.chip {
  @apply inline-flex items-center gap-2;
  @apply px-3 py-1.5;
  @apply text-sm font-medium;
  @apply bg-white dark:bg-gray-800;
  @apply border border-gray-300 dark:border-gray-600;
  @apply rounded-full;
  @apply transition-colors duration-150;
}

.chip:hover {
  @apply bg-gray-50 dark:bg-gray-700;
}

.chip-active {
  @apply bg-primary-50 dark:bg-primary-900/30;
  @apply border-primary-500;
  @apply text-primary-700 dark:text-primary-300;
}

.recent-search-item {
  @apply flex items-center gap-2;
  @apply w-full px-4 py-2;
  @apply text-left text-gray-700 dark:text-gray-300;
  @apply hover:bg-gray-100 dark:hover:bg-gray-800;
  @apply rounded-lg;
  @apply transition-colors duration-150;
}

.empty-state {
  @apply flex flex-col items-center justify-center;
  @apply py-12;
}
</style>
```

## Testing Strategy

### Unit Tests

Create `src/composables/__tests__/useShardWorker.spec.ts`:

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { useShardWorker } from '../useShardWorker'

describe('useShardWorker', () => {
  beforeEach(() => {
    // Mock Worker
    global.Worker = vi.fn() as unknown as typeof Worker
  })

  it('should initialize worker successfully', () => {
    const { initWorker, isReady } = useShardWorker()
    const result = initWorker()

    expect(result).toBe(true)
    // More assertions
  })

  it('should handle worker not supported', () => {
    // @ts-ignore
    global.Worker = undefined

    const { initWorker } = useShardWorker()
    const result = initWorker()

    expect(result).toBe(false)
  })

  // More tests...
})
```

### E2E Tests

Update `e2e/redesign.spec.ts`:

```typescript
import { test, expect } from '@playwright/test'

test.describe('v0.5 Redesign', () => {
  test('should display bottom navigation on mobile', async ({ page }) => {
    await page.setViewportSize({ width: 375, height: 667 }) // iPhone SE
    await page.goto('/')

    const bottomNav = page.locator('.bottom-nav')
    await expect(bottomNav).toBeVisible()

    // Verify navigation items
    await expect(bottomNav.locator('text=Search')).toBeVisible()
    await expect(bottomNav.locator('text=Calculator')).toBeVisible()
    await expect(bottomNav.locator('text=History')).toBeVisible()
    await expect(bottomNav.locator('text=Profile')).toBeVisible()
  })

  test('should display side rail on desktop', async ({ page }) => {
    await page.setViewportSize({ width: 1280, height: 720 })
    await page.goto('/')

    const sideRail = page.locator('.bottom-nav') // Same component, different layout
    await expect(sideRail).toHaveCSS('flex-direction', 'column')
  })

  test('should use Web Worker for shard import', async ({ page }) => {
    await page.goto('/')

    // Listen for console logs from worker
    const workerLogs: string[] = []
    page.on('console', (msg) => {
      if (msg.text().includes('Worker:')) {
        workerLogs.push(msg.text())
      }
    })

    // Trigger dataset load
    await page.waitForSelector('[data-dataset-loaded="true"]', { timeout: 60000 })

    // Verify worker was used
    expect(workerLogs.length).toBeGreaterThan(0)
    expect(workerLogs.some(log => log.includes('Parsed'))).toBe(true)
  })

  // More E2E tests...
})
```

## Performance Budgets

Update `lighthouserc.json`:

```json
{
  "ci": {
    "collect": {
      "url": ["http://localhost:4173/gluko/"],
      "numberOfRuns": 3
    },
    "assert": {
      "assertions": {
        "categories:performance": ["error", { "minScore": 0.9 }],
        "categories:accessibility": ["error", { "minScore": 0.95 }],
        "first-contentful-paint": ["error", { "maxNumericValue": 1800 }],
        "largest-contentful-paint": ["error", { "maxNumericValue": 2500 }],
        "total-blocking-time": ["error", { "maxNumericValue": 200 }],
        "cumulative-layout-shift": ["error", { "maxNumericValue": 0.1 }],
        "resource-summary:script:size": ["error", { "maxNumericValue": 153600 }],
        "resource-summary:stylesheet:size": ["error", { "maxNumericValue": 30720 }]
      }
    }
  }
}
```

## Build Configuration

Update `vite.config.ts`:

```typescript
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { visualizer } from 'rollup-plugin-visualizer'

export default defineConfig({
  plugins: [
    vue(),
    visualizer({
      filename: './dist/stats.html',
      open: false,
      gzipSize: true,
      brotliSize: true,
    }),
  ],
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          'vendor-vue': ['vue', 'vue-router', 'pinia'],
          'vendor-ui': ['reka-ui', 'lucide-vue-next'],
          'vendor-utils': ['@vueuse/core'],
        },
      },
    },
    chunkSizeWarningLimit: 600,
  },
  // ... rest of config
})
```

## Migration Checklist

### Phase 1: Foundation ✓
- [ ] Install Reka UI, Tailwind CSS, Lucide Icons
- [ ] Configure Tailwind with design tokens
- [ ] Set up PostCSS
- [ ] Remove Bootstrap dependencies
- [ ] Implement dark mode system
- [ ] Create base components (Button, Input, Card, Modal)

### Phase 2: Navigation ✓
- [ ] Build bottom navigation component
- [ ] Build nav item component
- [ ] Update app shell layout
- [ ] Test responsive behavior (mobile/desktop)
- [ ] Update routing configuration

### Phase 3: Performance ✓
- [ ] Create Web Worker for shard processing
- [ ] Implement worker composable
- [ ] Update shard loader to use worker
- [ ] Implement chunked IndexedDB writes
- [ ] Enhanced Service Worker caching

### Phase 4: View Migrations
- [ ] Migrate Search View
- [ ] Migrate Calculator View
- [ ] Migrate History View
- [ ] Migrate Profile/Settings View
- [ ] Remove all Bootstrap component usage

### Phase 5: Polish
- [ ] Add micro-interactions and animations
- [ ] Implement loading states and skeletons
- [ ] Accessibility audit (WCAG AA+)
- [ ] Performance optimization (Web Vitals)
- [ ] Cross-browser testing

### Phase 6: Testing & Documentation
- [ ] Update unit tests
- [ ] Update integration tests
- [ ] Update E2E tests
- [ ] Update user documentation
- [ ] Create migration guide
- [ ] Prepare release notes

## Known Issues & Solutions

### Issue: Bundle Size Increase
**Problem**: Reka UI and Tailwind add to bundle size
**Solution**:
- Tree-shaking (import only used components)
- Tailwind PurgeCSS (remove unused utilities)
- Code splitting (route-based chunks)
- **Target**: < 150 KB gzipped initial bundle

### Issue: Web Worker Overhead
**Problem**: Worker initialization adds latency
**Solution**:
- Initialize worker early (app mount)
- Graceful fallback to main thread
- Test on low-end devices
- **Target**: < 100ms worker init time

### Issue: Service Worker Cache Invalidation
**Problem**: Stale cached shards with new manifest
**Solution**:
- Version-based cache keys
- Manifest checksum validation
- Clear old caches on activate
- **Target**: Zero stale data issues

## Related Documentation

- **Release plan**: [v0.5-complete-redesign.md](../releases/v0.5-complete-redesign.md)
- **Design proposal**: [v0.x-complete-redesign-proposal.md](../releases/v0.x-complete-redesign-proposal.md)
- **Previous implementation**: [v0.3-shard-loading.md](v0.3-shard-loading.md)
- **Next release**: [v0.6-feature-enhancements.md](../releases/v0.6-feature-enhancements.md)
- Product goals: [PRODUCT.md](../PRODUCT.md)
- Architecture: [ARCHITECTURE.md](../ARCHITECTURE.md)
